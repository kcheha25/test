import xml.etree.ElementTree as ET

tree = ET.parse("fichier.xml")
root = tree.getroot()  

print("Racine:", root.tag)

for child in root:
    print("Balise:", child.tag, " | Attributs:", child.attrib, " | Texte:", child.text)

import xml.etree.ElementTree as ET

file_path = "fichier.xml"  
tree = ET.parse(file_path)
root = tree.getroot()

cox = root.find(".//cox")

if cox is not None:
    print("Avant modification :", cox.attrib)

    cox.set("value", "true")

    print("Après modification :", cox.attrib)

    tree.write(file_path, encoding="utf-8", xml_declaration=True)
else:
    print("Aucune balise <cox> trouvée")

import subprocess

exe_path = r"C:\chemin\vers\.exe"

subprocess.run([exe_path])


def calculate_semi_axes(T0, T1, T2, tol=1e-6):
    """Calcule les longueurs des demi-axes à partir des tenseurs centrés."""
    T2_centered = T2 - np.outer(T1, T1) / (2 * T0)

    eigenvalues, eigenvectors = np.linalg.eigh(T2_centered)

    kappa_3 = 4 * np.pi / 3
    factor = (2 * (3 + 2) / kappa_3) ** (1/(3 + 2))  # (10 / (4π/3))^(1/5)

    lambda1, lambda2, lambda3 = eigenvalues

    a1 = factor * (lambda1 ** 0.4) / ((lambda2 * lambda3) ** 0.1)
    a2 = factor * (lambda2 ** 0.4) / ((lambda1 * lambda3) ** 0.1)
    a3 = factor * (lambda3 ** 0.4) / ((lambda1 * lambda2) ** 0.1)

    semi_axes = np.array([a1, a2, a3])

    if abs(a1 - a2) < tol and abs(a1 - a3) > tol:
        semi_axes = np.array([a1, a3, a2])
    elif abs(a1 - a3) < tol and abs(a1 - a2) > tol:
        semi_axes = np.array([a1, a2, a3])
    elif abs(a2 - a3) < tol and abs(a2 - a1) > tol:
        semi_axes = np.array([a2, a1, a3])

    semi_axes = np.rint(semi_axes).astype(int)

    return semi_axes, eigenvectors

from flask import Flask, render_template, request, jsonify, send_from_directory
from PIL import Image
import os

app = Flask(__name__)

UPLOAD_FOLDER = "static/upload"
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

@app.route("/")
def index():
    return render_template("index.html")

# Nouvelle fonction indépendante pour gérer upload et affichage PNG
@app.route("/upload_preview", methods=["POST"])
def upload_preview():
    if "image" not in request.files:
        return jsonify({"error": "Aucune image reçue"}), 400

    file = request.files["image"]
    orig_filename = file.filename
    orig_ext = os.path.splitext(orig_filename)[1].lower()

    # Sauvegarde de l'image originale
    orig_path = os.path.join(UPLOAD_FOLDER, f"uploadedimage{orig_ext}")
    file.save(orig_path)

    # Conversion en PNG pour affichage
    img = Image.open(orig_path)
    png_path = os.path.join(UPLOAD_FOLDER, "uploadedimage.png")
    img.save(png_path, "PNG")

    # Retourne le chemin PNG pour affichage
    return jsonify({"preview": f"/{png_path.replace(os.sep, '/')}"})


@app.route("/upload/<path:filename>")
def uploaded_file(filename):
    return send_from_directory(UPLOAD_FOLDER, filename)

<!-- Prévisualisation -->
<script>
const uploadInput = document.getElementById("image-upload");
const previewImg = document.getElementById("preview-img");

uploadInput.addEventListener("change", function(){
  const file = this.files[0];
  if (!file) return;

  const formData = new FormData();
  formData.append("image", file);

  // Envoi à la nouvelle fonction Flask
  fetch("/upload_preview", {method:"POST", body:formData})
    .then(res => res.json())
    .then(data => {
      previewImg.src = data.preview + "?ts=" + new Date().getTime();
    })
    .catch(err => console.error(err));
});
</script>
