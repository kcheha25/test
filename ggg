import json
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats

def calculate_optimal_windows(json_path, plot_distribution=False):
    """
    Calcule le nombre optimal de fenêtres en analysant la distribution des pics
    Args:
        json_path: Chemin vers le fichier JSON contenant les chromatogrammes
        plot_distribution: Booléen pour afficher la distribution des distances
    Returns:
        optimal_windows: Nombre recommandé de fenêtres
        analysis_report: Dictionnaire contenant les métriques d'analyse
    """
    
    # 1. Chargement des données
    with open(json_path) as f:
        data = json.load(f)
    
    # 2. Extraction de tous les pics et calcul des distances
    all_peaks = []
    distances = []
    
    for chrom in data:
        if 'pics' in chrom and chrom['pics']:
            peaks = sorted([float(rt) for rt in chrom['pics'].keys()])
            all_peaks.extend(peaks)
            if len(peaks) > 1:
                distances.extend(np.diff(peaks))
    
    if not distances:
        return 256, {"message": "Pas assez de pics pour l'analyse, utilisation de la valeur par défaut 256"}
    
    # 3. Analyse statistique
    distances = np.array(distances)
    mean_dist = np.mean(distances)
    median_dist = np.median(distances)
    mode_dist = stats.mode(distances, keepdims=True)[0][0]
    
    # 4. Calcul du nombre optimal de fenêtres (3 méthodes)
    signal_length = 71840  # Longueur fixe de vos chromatogrammes
    
    # Méthode 1: Basée sur la distance médiane
    windows_median = int(signal_length / (median_dist * 2))  # Espacement de 2x la médiane
    
    # Méthode 2: Basée sur le clustering automatique (KDE)
    kde = stats.gaussian_kde(distances)
    x = np.linspace(0, np.max(distances), 1000)
    y = kde(x)
    mode_kde = x[np.argmax(y)]
    windows_kde = int(signal_length / (mode_kde * 1.5))
    
    # Méthode 3: Basée sur le nombre moyen de pics
    avg_peaks = len(all_peaks) / len(data)
    windows_peaks = int(avg_peaks * 4)  # 4 fenêtres par pic moyen
    
    # 5. Sélection de la valeur optimale (médiane des 3 méthodes)
    methods = [windows_median, windows_kde, windows_peaks]
    optimal_windows = int(np.median(methods))
    
    # 6. Validation des limites
    min_windows = 32   # Minimum absolu
    max_windows = 1024 # Maximum absolu
    optimal_windows = np.clip(optimal_windows, min_windows, max_windows)
    
    # 7. Visualisation (optionnelle)
    if plot_distribution:
        plt.figure(figsize=(12, 6))
        plt.hist(distances, bins=50, density=True, alpha=0.7, label='Distances réelles')
        plt.plot(x, y, 'r-', label='Estimation KDE')
        plt.axvline(median_dist, color='g', linestyle='--', label=f'Médiane: {median_dist:.2f}')
        plt.axvline(mode_kde, color='b', linestyle=':', label=f'Mode KDE: {mode_kde:.2f}')
        plt.title(f'Distribution des distances entre pics\nFenêtres recommandées: {optimal_windows}')
        plt.xlabel('Distance entre pics')
        plt.ylabel('Densité')
        plt.legend()
        plt.show()
    
    # 8. Rapport d'analyse
    analysis_report = {
        "optimal_windows": optimal_windows,
        "signal_length": signal_length,
        "total_chromatograms": len(data),
        "total_peaks": len(all_peaks),
        "mean_distance": float(mean_dist),
        "median_distance": float(median_dist),
        "mode_distance_kde": float(mode_kde),
        "average_peaks_per_chrom": len(all_peaks)/len(data),
        "calculation_methods": {
            "median_based": windows_median,
            "kde_based": windows_kde,
            "peak_count_based": windows_peaks
        },
        "window_size_pixels": signal_length/optimal_windows
    }
    
    return optimal_windows, analysis_report

# Exemple d'utilisation
if __name__ == "__main__":
    json_path = "chromatogrammes.json"
    optimal_windows, report = calculate_optimal_windows(json_path, plot_distribution=True)
    
    print("\n=== Rapport d'analyse ===")
    print(f"Nombre optimal de fenêtres: {optimal_windows}")
    print(f"Méthodes de calcul:")
    print(f"- Basée sur médiane: {report['calculation_methods']['median_based']}")
    print(f"- Basée sur KDE: {report['calculation_methods']['kde_based']}")
    print(f"- Basée sur nombre de pics: {report['calculation_methods']['peak_count_based']}")
    print(f"\nTaille de fenêtre: {report['window_size_pixels']:.2f} points")
    print(f"Distance médiane entre pics: {report['median_distance']:.2f} points")