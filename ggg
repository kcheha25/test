class ChromatogramLabelEncoder:
    def __init__(self, signal_length=71840):
        self.signal_length = signal_length
        self.signal = np.linspace(0, signal_length, num=signal_length)

    def encode(self, peaks_data, chromatogram):
        """
        peaks_data: Dictionnaire {position_pic: [composant, borne_gauche, borne_droite]}
        chromatogram: Intensités du signal (array de taille 71840)
        
        Retourne: array de shape (signal_length, 3) [prob, loc_norm, area]
        """
        labels = np.zeros((self.signal_length, 3))  # [prob, loc_norm, area]
        
        for rt_str, (_, left_bound, right_bound) in peaks_data.items():
            # Convertir la position du pic
            try:
                rt = float(rt_str)
            except ValueError:
                continue  # Sauter les erreurs

            # Trouver l'indice du pic
            closest_idx = np.argmin(np.abs(self.signal - rt))
            
            # Calcul de loc_norm
            loc_norm = rt / self.signal_length

            # Calcul de l'aire sous la courbe entre left_bound et right_bound
            left_idx = np.argmin(np.abs(self.signal - float(left_bound)))
            right_idx = np.argmin(np.abs(self.signal - float(right_bound)))
            if left_idx >= right_idx:
                continue  # On saute les cas invalides

            area = np.trapz(chromatogram[left_idx:right_idx+1], self.signal[left_idx:right_idx+1])

            # Remplir le label
            labels[closest_idx, 0] = 1.0  # Probabilité
            labels[closest_idx, 1] = loc_norm  # Position normalisée
            labels[closest_idx, 2] = area  # Aire sous le pic
        
        return labels
