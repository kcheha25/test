import pandas as pd
import numpy as np

file_path = "chromatogrammes.json"
df = pd.read_json(file_path)

# On ne garde que les chromatogrammes avec pics
df = df.dropna(subset=['pics'])
df = df[df["x"].apply(len) == 71840]

# On coupe les chromatogrammes à x <= 150
def truncate(row):
    mask = np.array(row["x"]) <= 150
    row["x"] = np.array(row["x"])[mask].tolist()
    row["y"] = np.array(row["y"])[mask].tolist()
    return row

df = df.apply(truncate, axis=1)

# Taille après découpage
sequence_length = df.iloc[0]["x"].__len__()

# Input X : (n, sequence_length, 2)
X = np.array([np.column_stack((row["x"], row["y"])) for _, row in df.iterrows()])

# ======================
# Normalisation de X
# ======================

# Normalisation du temps entre [0,1]
X[:, :, 0] = X[:, :, 0] / 150.0

# Normalisation de l'intensité par chromatogramme
for i in range(X.shape[0]):
    max_intensity = np.max(X[i, :, 1])
    if max_intensity > 0:
        X[i, :, 1] /= max_intensity

# ======================
# Création de Y (one-hot)
# ======================

# Label Y one-hot : (n, sequence_length, 4)
Y = np.zeros((len(df), sequence_length, 4), dtype=np.int32)

for i, (_, row) in enumerate(df.iterrows()):
    x_time = np.array(row["x"])  # temps après découpage
    
    for pic_time, data in row["pics"].items():
        borne_avant_time = data[1]
        pic_time = float(pic_time)
        borne_apres_time = data[2]

        # Vérification que l'événement est toujours dans l'intervalle <=150
        if pic_time > 150:
            continue

        borne_avant_idx = np.argmin(np.abs(x_time - borne_avant_time))
        pic_idx = np.argmin(np.abs(x_time - pic_time))
        borne_apres_idx = np.argmin(np.abs(x_time - borne_apres_time))

        Y[i, borne_avant_idx, 1] = 1
        Y[i, pic_idx, 2] = 1
        Y[i, borne_apres_idx, 3] = 1

# Classe "aucun"
Y[:, :, 0] = (Y.sum(axis=-1) == 0).astype(int)
