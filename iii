import tkinter as tk
from tkinter import filedialog, messagebox
from PIL import Image, ImageTk
import math
import os
import openpyxl

class ImageAnnotator:
    def __init__(self, root):
        self.root = root
        self.root.title("Image Annotator")
        self.root.state('zoomed')
        self.root.configure(bg="#f0f0f0")

        # Layout principal centrÃ©
        self.top_frame = tk.Frame(root, bg="#333")
        self.top_frame.pack(side="top", anchor="center", pady=10)

        self.upload_btn = tk.Button(self.top_frame, text="ðŸ“‚ Upload Image", command=self.upload_image,
                                    font=("Segoe UI", 10, "bold"), bg="#4CAF50", fg="white", padx=10, pady=5)
        self.upload_btn.pack(side="left", padx=10)

        self.save_btn = tk.Button(self.top_frame, text="ðŸ’¾ Save", command=self.save_data,
                                  font=("Segoe UI", 10, "bold"), bg="#2196F3", fg="white", padx=10, pady=5)
        self.save_btn.pack(side="left", padx=10)

        self.canvas = tk.Canvas(root, cursor="cross", bg="white", highlightthickness=0)
        self.canvas.pack(fill="both", expand=True)

        self.image = None
        self.image_path = None
        self.tk_image = None
        self.center_point = None
        self.second_point = None
        self.pixel_to_unit_ratio = None
        self.rect = None
        self.rect_coords = None
        self.handles = []
        self.active_handle = None
        self.resize_handle_size = 6

        self.canvas.bind("<Button-1>", self.click_event)
        self.canvas.bind("<B1-Motion>", self.drag_rectangle)
        self.canvas.bind("<ButtonRelease-1>", self.stop_drag)

    def upload_image(self):
        file_path = filedialog.askopenfilename(filetypes=[("Image files", "*.png;*.jpg;*.jpeg;*.bmp")])
        if file_path:
            self.image_path = file_path
            self.image = Image.open(file_path)
            self.tk_image = ImageTk.PhotoImage(self.image)
            self.canvas.delete("all")
            self.canvas.config(scrollregion=(0, 0, self.tk_image.width(), self.tk_image.height()))
            self.canvas.create_image(0, 0, image=self.tk_image, anchor="nw", tags="image")
            self.reset_state()

    def reset_state(self):
        self.center_point = None
        self.second_point = None
        self.pixel_to_unit_ratio = None
        self.rect = None
        self.rect_coords = None
        self.canvas.delete("point")
        self.canvas.delete("rect")
        self.canvas.delete("label")
        self.remove_handles()

    def click_event(self, event):
        x, y = event.x, event.y

        # VÃ©rifie si clic sur un handle pour redimensionnement
        for i, handle in enumerate(self.handles):
            x0, y0, x1, y1 = self.canvas.coords(handle)
            if x0 <= x <= x1 and y0 <= y <= y1:
                self.active_handle = i
                return

        if not self.center_point:
            self.center_point = (x, y)
            self.canvas.create_oval(x-4, y-4, x+4, y+4, fill="red", tags="point")
        elif not self.second_point:
            self.second_point = (x, y)
            self.canvas.create_oval(x-4, y-4, x+4, y+4, fill="green", tags="point")
            self.draw_distance_line()
            self.pixel_to_unit_ratio = 3.1 / self.compute_distance(self.center_point, self.second_point)
        else:
            if not self.rect:
                w, h = 100, 80
                x0, y0 = x - w//2, y - h//2
                x1, y1 = x + w//2, y + h//2
                self.rect_coords = [x0, y0, x1, y1]
                self.rect = self.canvas.create_rectangle(*self.rect_coords, outline="#2196F3", width=2, tags="rect")
                self.update_rectangle_info()

    def draw_distance_line(self):
        x0, y0 = self.center_point
        x1, y1 = self.second_point
        self.canvas.create_line(x0, y0, x1, y1, fill="purple", width=2, tags="point")
        distance_px = self.compute_distance(self.center_point, self.second_point)
        self.canvas.create_text((x0 + x1)//2, (y0 + y1)//2 - 12,
                                text=f"{distance_px:.1f} px = 3.1 units", fill="black",
                                font=("Segoe UI", 10, "bold"), tags="label")

    def compute_distance(self, p1, p2):
        return math.hypot(p2[0] - p1[0], p2[1] - p1[1])

    def drag_rectangle(self, event):
        x, y = event.x, event.y
        if self.rect_coords and self.rect:
            if self.active_handle is not None:
                x0, y0, x1, y1 = self.rect_coords
                coords = [x0, y0, x1, y1]
                idx = self.active_handle
                if idx == 0:  # top-left
                    coords[0], coords[1] = x, y
                elif idx == 1:  # top-right
                    coords[2], coords[1] = x, y
                elif idx == 2:  # bottom-right
                    coords[2], coords[3] = x, y
                elif idx == 3:  # bottom-left
                    coords[0], coords[3] = x, y
                self.rect_coords = coords
                self.canvas.coords(self.rect, *self.rect_coords)
                self.update_rectangle_info()
            else:
                # DÃ©placement du rectangle
                x0, y0, x1, y1 = self.rect_coords
                w, h = x1 - x0, y1 - y0
                new_x0, new_y0 = x - w//2, y - h//2
                new_x1, new_y1 = x + w//2, y + h//2
                self.rect_coords = [new_x0, new_y0, new_x1, new_y1]
                self.canvas.coords(self.rect, *self.rect_coords)
                self.update_rectangle_info()

    def stop_drag(self, event):
        self.active_handle = None

    def draw_resize_handles(self):
        self.remove_handles()
        x0, y0, x1, y1 = self.rect_coords
        corners = [(x0, y0), (x1, y0), (x1, y1), (x0, y1)]
        for x, y in corners:
            handle = self.canvas.create_oval(
                x - self.resize_handle_size, y - self.resize_handle_size,
                x + self.resize_handle_size, y + self.resize_handle_size,
                fill="orange", outline="black", tags="rect"
            )
            self.handles.append(handle)

    def remove_handles(self):
        for handle in self.handles:
            self.canvas.delete(handle)
        self.handles = []

    def update_rectangle_info(self):
        self.canvas.delete("label")
        if self.center_point and self.rect_coords:
            cx, cy = self.center_point
            x0, y0, x1, y1 = self.rect_coords
            corners = [(x0, y0), (x1, y0), (x1, y1), (x0, y1)]
            for x, y in corners:
                dx = (x - cx) * (self.pixel_to_unit_ratio or 1)
                dy = (y - cy) * (self.pixel_to_unit_ratio or 1)
                self.canvas.create_text(x + 10, y - 10, text=f"{dx:.2f}, {dy:.2f}",
                                        fill="#333", font=("Segoe UI", 9, "bold"), tags="label")
            self.draw_resize_handles()

    def save_data(self):
        if not self.rect_coords or not self.image_path:
            messagebox.showwarning("Erreur", "Veuillez d'abord charger une image et dessiner un rectangle.")
            return

        x0, y0, x1, y1 = self.rect_coords
        corners = [(x0, y0), (x1, y0), (x1, y1), (x0, y1)]

        # CrÃ©e le classeur Excel
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "Rectangle Coordinates"
        ws.append(["Point", "X", "Y"])

        for i, (x, y) in enumerate(corners, start=1):
            ws.append([f"P{i}", round(x), round(y)])

        # Sauvegarde dans le mÃªme dossier que l'image
        base, ext = os.path.splitext(os.path.basename(self.image_path))
        folder = os.path.dirname(self.image_path)
        excel_path = os.path.join(folder, f"{base}.xlsx")

        try:
            wb.save(excel_path)
            messagebox.showinfo("SuccÃ¨s", f"CoordonnÃ©es sauvegardÃ©es :\n{excel_path}")
        except Exception as e:
            messagebox.showerror("Erreur", f"Impossible de sauvegarder le fichier :\n{e}")


if __name__ == "__main__":
    root = tk.Tk()
    app = ImageAnnotator(root)
    root.mainloop()




import tkinter as tk
from tkinter import filedialog, messagebox
from PIL import Image, ImageTk
import math
import os
import openpyxl

class ImageAnnotator:
    def __init__(self, root):
        self.root = root
        self.root.title("Image Annotator")
        self.root.state('zoomed')
        self.root.configure(bg="#f0f0f0")

        self.top_frame = tk.Frame(root, bg="#333")
        self.top_frame.pack(side="top", anchor="center", pady=10)

        self.upload_btn = tk.Button(self.top_frame, text="ðŸ“‚ Upload Image", command=self.upload_image,
                                    font=("Segoe UI", 10, "bold"), bg="#4CAF50", fg="white", padx=10, pady=5)
        self.upload_btn.pack(side="left", padx=10)

        self.add_rect_btn = tk.Button(self.top_frame, text="âž• Ajouter Rectangle", command=self.add_new_rectangle_mode,
                                      font=("Segoe UI", 10, "bold"), bg="#FF9800", fg="white", padx=10, pady=5)
        self.add_rect_btn.pack(side="left", padx=10)

        self.save_btn = tk.Button(self.top_frame, text="ðŸ’¾ Save", command=self.save_data,
                                  font=("Segoe UI", 10, "bold"), bg="#2196F3", fg="white", padx=10, pady=5)
        self.save_btn.pack(side="left", padx=10)

        self.canvas = tk.Canvas(root, cursor="cross", bg="white", highlightthickness=0)
        self.canvas.pack(fill="both", expand=True)

        self.image = None
        self.image_path = None
        self.tk_image = None

        self.center_point = None
        self.second_point = None
        self.pixel_to_unit_ratio = None

        self.rectangles = []  # Liste des rectangles
        self.current_rect = None
        self.active_handle = None
        self.resize_handle_size = 6
        self.adding_new_rect = False

        self.zoom_factor = 1.0
        self.min_zoom = 0.2
        self.max_zoom = 5.0

        self.canvas.bind("<Button-1>", self.click_event)
        self.canvas.bind("<B1-Motion>", self.drag_rectangle)
        self.canvas.bind("<ButtonRelease-1>", self.stop_drag)
        self.canvas.tag_bind("handle", "<Button-1>", self.select_handle)

        # Bind molette souris (Windows/macOS/Linux)
        self.canvas.bind("<MouseWheel>", self.zoom)        # Windows/macOS
        self.canvas.bind("<Button-4>", self.zoom)          # Linux scroll up
        self.canvas.bind("<Button-5>", self.zoom)          # Linux scroll down

    def upload_image(self):
        file_path = filedialog.askopenfilename(filetypes=[("Image files", "*.png;*.jpg;*.jpeg;*.bmp")])
        if file_path:
            self.image_path = file_path
            self.image = Image.open(file_path)
            self.zoom_factor = 1.0
            self.display_image()
            self.reset_state()

    def display_image(self):
        w, h = self.image.size
        resized = self.image.resize((int(w * self.zoom_factor), int(h * self.zoom_factor)), Image.LANCZOS)
        self.tk_image = ImageTk.PhotoImage(resized)
        self.canvas.delete("all")
        self.canvas.config(scrollregion=(0, 0, self.tk_image.width(), self.tk_image.height()))
        self.canvas.create_image(self.tk_image.width()//2, self.tk_image.height()//2,
                                 image=self.tk_image, anchor="center", tags="image")
        self.redraw_points_and_rectangles()

    def redraw_points_and_rectangles(self):
        self.canvas.delete("point")
        self.canvas.delete("label")
        self.canvas.delete("handle")
        self.canvas.delete("rect")

        if self.center_point:
            cx, cy = self.transform_coords(self.center_point)
            self.canvas.create_oval(cx-4, cy-4, cx+4, cy+4, fill="red", tags="point")
        if self.second_point:
            sx, sy = self.transform_coords(self.second_point)
            self.canvas.create_oval(sx-4, sy-4, sx+4, sy+4, fill="green", tags="point")
            self.draw_distance_line()

        for rect in self.rectangles:
            x0, y0, x1, y1 = rect["coords"]
            zx0, zy0 = self.transform_coords((x0, y0))
            zx1, zy1 = self.transform_coords((x1, y1))
            rect_id = self.canvas.create_rectangle(zx0, zy0, zx1, zy1, outline="#2196F3", width=2, tags="rect")
            rect["id"] = rect_id
            self.update_rectangle_info(rect)

    def transform_coords(self, point):
        x, y = point
        return x * self.zoom_factor, y * self.zoom_factor

    def inverse_transform_coords(self, point):
        x, y = point
        return x / self.zoom_factor, y / self.zoom_factor

    def zoom(self, event):
        if event.num == 4 or event.delta > 0:
            factor = 1.1
        elif event.num == 5 or event.delta < 0:
            factor = 0.9
        else:
            return

        new_zoom = self.zoom_factor * factor
        if new_zoom < self.min_zoom or new_zoom > self.max_zoom:
            return
        self.zoom_factor = new_zoom

        self.display_image()

    def add_new_rectangle_mode(self):
        self.adding_new_rect = True

    def click_event(self, event):
        x, y = self.inverse_transform_coords((event.x, event.y))

        if not self.center_point:
            self.center_point = (x, y)
            self.canvas.create_oval(event.x-4, event.y-4, event.x+4, event.y+4, fill="red", tags="point")
        elif not self.second_point:
            self.second_point = (x, y)
            self.canvas.create_oval(event.x-4, event.y-4, event.x+4, event.y+4, fill="green", tags="point")
            self.draw_distance_line()
            self.pixel_to_unit_ratio = 3.1 / self.compute_distance(self.center_point, self.second_point)
        elif self.adding_new_rect:
            w, h = 100, 80
            x0, y0 = x - w//2, y - h//2
            x1, y1 = x + w//2, y + h//2
            rect_id = self.canvas.create_rectangle(
                *(self.transform_coords((x0, y0)) + self.transform_coords((x1, y1))),
                outline="#2196F3", width=2, tags="rect")
            rect_info = {
                "id": rect_id,
                "coords": [x0, y0, x1, y1],
                "handles": []
            }
            self.rectangles.append(rect_info)
            self.current_rect = rect_info
            self.update_rectangle_info(rect_info)
            self.adding_new_rect = False
        else:
            for rect in self.rectangles:
                x0, y0, x1, y1 = rect["coords"]
                if x0 <= x <= x1 and y0 <= y <= y1:
                    self.current_rect = rect
                    self.update_rectangle_info(rect)
                    break

    def select_handle(self, event):
        x, y = event.x, event.y
        for rect in self.rectangles:
            for idx, handle_id in enumerate(rect["handles"]):
                coords = self.canvas.coords(handle_id)
                if len(coords) != 4:
                    continue
                x0, y0, x1, y1 = coords
                if x0 <= x <= x1 and y0 <= y <= y1:
                    self.current_rect = rect
                    self.active_handle = idx
                    return

    def compute_distance(self, p1, p2):
        return math.hypot(p2[0] - p1[0], p2[1] - p1[1])

    def draw_distance_line(self):
        if not self.center_point or not self.second_point:
            return
        cx, cy = self.transform_coords(self.center_point)
        sx, sy = self.transform_coords(self.second_point)
        self.canvas.delete("point_line")
        self.canvas.create_line(cx, cy, sx, sy, fill="purple", width=2, tags=("point", "point_line"))
        distance_px = self.compute_distance(self.center_point, self.second_point)
        self.canvas.delete("label_distance")
        self.canvas.create_text((cx + sx)//2, (cy + sy)//2 - 12,
                                text=f"{distance_px:.1f} px = 3.1 units", fill="black",
                                font=("Segoe UI", 10, "bold"), tags=("label", "label_distance"))

    def drag_rectangle(self, event):
        if not self.current_rect:
            return

        x, y = self.inverse_transform_coords((event.x, event.y))
        coords = self.current_rect["coords"]

        if self.active_handle is not None:
            idx = self.active_handle
            if idx == 0:
                coords[0], coords[1] = x, y
            elif idx == 1:
                coords[2], coords[1] = x, y
            elif idx == 2:
                coords[2], coords[3] = x, y
            elif idx == 3:
                coords[0], coords[3] = x, y
        else:
            x0, y0, x1, y1 = coords
            w, h = x1 - x0, y1 - y0
            coords[0], coords[1], coords[2], coords[3] = x - w//2, y - h//2, x + w//2, y + h//2

        x0, y0, x1, y1 = coords
        if x0 > x1:
            x0, x1 = x1, x0
        if y0 > y1:
            y0, y1 = y1, y0
        self.current_rect["coords"] = [x0, y0, x1, y1]

        zx0, zy0 = self.transform_coords((x0, y0))
        zx1, zy1 = self.transform_coords((x1, y1))
        self.canvas.coords(self.current_rect["id"], zx0, zy0, zx1, zy1)
        self.update_rectangle_info(self.current_rect)

    def stop_drag(self, event):
        self.active_handle = None

    def update_rectangle_info(self, rect):
        self.canvas.delete("label")
        self.canvas.delete("handle")
        for handle in rect["handles"]:
            self.canvas.delete(handle)
        rect["handles"].clear()

        x0, y0, x1, y1 = rect["coords"]
        corners = [(x0, y0), (x1, y0), (x1, y1), (x0, y1)]

        for i, (x, y) in enumerate(corners):
            zx, zy = self.transform_coords((x, y))
            dx = (x - self.center_point[0]) * (self.pixel_to_unit_ratio or 1)
            dy = (y - self.center_point[1]) * (self.pixel_to_unit_ratio or 1)
            self.canvas.create_text(zx + 10, zy - 10, text=f"{dx:.2f}, {dy:.2f}",
                                    fill="#333", font=("Segoe UI", 9, "bold"), tags="label")
            handle = self.canvas.create_oval(
                zx - self.resize_handle_size, zy - self.resize_handle_size,
                zx + self.resize_handle_size, zy + self.resize_handle_size,
                fill="orange", outline="black", tags=("handle",)
            )
            rect["handles"].append(handle)

    def save_data(self):
        if not self.rectangles:
            messagebox.showwarning("Warning", "Aucun rectangle Ã  sauvegarder.")
            return
    
        if not self.image_path:
            messagebox.showwarning("Warning", "Aucune image chargÃ©e.")
            return
    
        # Construire chemin Excel avec mÃªme nom que l'image
        base_dir = os.path.dirname(self.image_path)
        base_name = os.path.splitext(os.path.basename(self.image_path))[0]
        excel_path = os.path.join(base_dir, base_name + ".xlsx")
    
        wb = openpyxl.Workbook()
        ws = wb.active
        ws.title = "Annotations"
    
        # En-tÃªtes
        ws.append([
            "Rectangle",
            "Top-Left (units)", 
            "Top-Right (units)",
            "Bottom-Right (units)", 
            "Bottom-Left (units)"
        ])
    
        for i, rect in enumerate(self.rectangles, 1):
            x0, y0, x1, y1 = rect["coords"]
            corners = [
                (x0, y0),  # Top-left
                (x1, y0),  # Top-right
                (x1, y1),  # Bottom-right
                (x0, y1)   # Bottom-left
            ]
    
            # Conversion en unitÃ©s relatives au center_point
            corners_units = [
                (
                    (x - self.center_point[0]) * (self.pixel_to_unit_ratio or 1),
                    (y - self.center_point[1]) * (self.pixel_to_unit_ratio or 1)
                )
                for x, y in corners
            ]
    
            # Formatage string (x, y) pour chaque coin
            corners_str = [f"({cx:.2f}, {cy:.2f})" for cx, cy in corners_units]
    
            ws.append([i] + corners_str)
    
        try:
            wb.save(excel_path)
            messagebox.showinfo("Success", f"DonnÃ©es sauvegardÃ©es dans\n{excel_path}")
        except Exception as e:
            messagebox.showerror("Error", f"Erreur lors de la sauvegarde:\n{e}")


    def reset_state(self):
        self.center_point = None
        self.second_point = None
        self.pixel_to_unit_ratio = None
        self.rectangles.clear()
        self.current_rect = None
        self.active_handle = None
        self.adding_new_rect = False

if __name__ == "__main__":
    root = tk.Tk()
    app = ImageAnnotator(root)
    root.mainloop()
