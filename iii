results = []

while i < len(probs_full) - 3:
    if probs_full[i] > threshold:
        window = probs_full[i - 3:i + 4]
        if np.any(window > threshold):
            idx_window = np.arange(i - 3, i + 4)
            idx_max_intensity = idx_window[np.argmax(y_full[idx_window])]
            detected_peaks.append(idx_max_intensity)

            pic_time_detected = x_full[idx_max_intensity]
            pic_time_normalized = pic_time_detected / 150.0

            # Trouver les voisins les plus proches
            _, indices = nbrs.kneighbors([[pic_time_normalized]])
            assigned_name = "UNKNOWN"
            alternatives = []

            for idx in indices[0]:
                proposed_name = component_names[idx]
                if not component_assigned_flags[proposed_name] and assigned_name == "UNKNOWN":
                    assigned_name = proposed_name
                    component_assigned_flags[proposed_name] = True
                else:
                    alternatives.append(proposed_name)

            # Ajouter au dictionnaire
            pic_info_dict[pic_time_detected * 150.0] = assigned_name

            # Ajouter aux résultats Excel
            results.append({
                "Temps du pic (s)": round(pic_time_detected * 150.0, 2),
                "Composant assigné": assigned_name,
                "Alternative 1": alternatives[0] if len(alternatives) > 0 else "",
                "Alternative 2": alternatives[1] if len(alternatives) > 1 else ""
            })

            i += 4
        else:
            i += 1
    else:
        i += 1

# Sauvegarder dans un fichier Excel
df_results = pd.DataFrame(results)
df_results.to_excel("resultats_pics.xlsx", index=False)

print("Résultats sauvegardés dans resultats_pics.xlsx")