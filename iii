random_idx = random.randint(0, len(df) - 1)  
# On sélectionne aléatoirement un index dans le DataFrame pour prendre un exemple de chromatogramme

row = truncate(df.iloc[random_idx])  
# On applique une fonction de prétraitement (truncate) sur la ligne sélectionnée pour réduire/nettoyer les données

x = np.array(row["x"])  
# On extrait les valeurs de temps (ou distance) en tant que tableau numpy

y = np.array(row["y"])  
# On extrait les valeurs d’intensité correspondantes

# Étape 2 : Normalisation des intensités
y = y / np.max(y)  
# On normalise les intensités pour que la valeur maximale soit égale à 1 (échelle uniforme)

# Étape 3 : Segmentation
segments = []  
# On initialise la liste des segments normalisés à prédire

segment_size = 1000  
# On définit la taille de chaque segment pour le modèle (1000 points)

num_segments = len(x) // segment_size  
# On calcule combien de segments complets on peut former à partir du signal

segments = []  
x_segments = []  
y_segments = []  
# On prépare les listes pour stocker les segments x/y bruts et les segments combinés

for i in range(num_segments):  
    # On parcourt chaque segment complet dans le signal
    start = i * segment_size  
    end = start + segment_size  
    segment_x = x[start:end]  
    segment_y = y[start:end]  
    # On extrait les sous-parties correspondantes de x et y

    segment_input = np.stack([segment_x, segment_y], axis=-1)  
    # On combine x et y dans une matrice (segment_size, 2) pour l’entrée du modèle

    segments.append(segment_input)  
    # On ajoute le segment formaté à la liste pour le modèle

    x_segments.append(segment_x)  
    y_segments.append(segment_y)  
    # On garde aussi les x et y séparément pour la reconstruction après prédiction

# Étape 4 : Inférence segment par segment
probs_segments = []  
# On initialise une liste pour stocker les probabilités prédites par segment

for seg in segments:  
    seg_input = np.expand_dims(seg, axis=0)  # (1, 1000, 2)  
    # On ajoute une dimension batch pour la prédiction avec le modèle

    pred = model.predict(seg_input, verbose=0)  # (1, 1000, 1) ou (1, 1000)  
    # On applique le modèle sur le segment

    if pred.ndim == 3:  
        pred = pred[0, :, 0]  
        # Si le résultat est 3D (batch, time, 1), on l’aplatit
    else:  
        pred = pred[0]  
        # Si déjà 2D, on garde la première ligne

    probs_segments.append(pred)  
    # On ajoute les probabilités du segment à la liste globale

x_full = np.concatenate(x_segments)  
# On reconstitue le vecteur x complet en concaténant tous les segments

y_full = np.concatenate(y_segments)  
# On fait de même pour les intensités

probs_full = np.concatenate(probs_segments)  
# On reconstitue les probabilités prédictes sur tout le signal
