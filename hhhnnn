import cv2
import numpy as np
import matplotlib.pyplot as plt
from mmrotate.apis import inference_detector, init_detector

def apply_fourier_transform(image):
    """
    Applique la transformÃ©e de Fourier sur une image et retourne le spectre de frÃ©quence.
    :param image: Image d'entrÃ©e (numpy array)
    :return: Spectre de frÃ©quence
    """
    # Convertir l'image en niveau de gris si nÃ©cessaire
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Appliquer la transformÃ©e de Fourier sur l'image
    f = np.fft.fft2(gray_image)
    fshift = np.fft.fftshift(f)  # DÃ©caler les frÃ©quences basses au centre

    # Calculer la magnitude du spectre
    magnitude_spectrum = np.abs(fshift)

    return magnitude_spectrum, fshift

def plot_bboxes_with_fourier(image, result):
    """
    Affiche l'image avec les boÃ®tes englobantes dÃ©tectÃ©es et Ã  cÃ´tÃ©, la transformÃ©e de Fourier pour chaque ROI.
    :param image: Image originale (numpy array)
    :param result: RÃ©sultats des dÃ©tections (liste de bboxes [x, y, w, h, angle, score])
    """
    # Copier l'image originale pour dessiner les boÃ®tes englobantes
    image_copy = image.copy()

    for i, bbox in enumerate(result[0]):  # result[0] est un tableau de bboxes
        x, y, w, h, angle, score = bbox

        # DÃ©couper la rÃ©gion d'intÃ©rÃªt (ROI) de l'image
        roi = image[int(y):int(y+h), int(x):int(x+w)]

        # Appliquer la transformÃ©e de Fourier sur la ROI
        magnitude_spectrum, _ = apply_fourier_transform(roi)

        # Afficher l'image originale avec la boÃ®te englobante
        cv2.rectangle(image_copy, (int(x), int(y)), (int(x + w), int(y + h)), (0, 255, 0), 2)

        # Tracer l'image avec la transformÃ©e de Fourier
        plt.figure(figsize=(12, 6))

        # Image originale avec bbox
        plt.subplot(1, 2, 1)
        plt.imshow(cv2.cvtColor(image_copy, cv2.COLOR_BGR2RGB))
        plt.title(f"Image with bbox {i}")
        plt.axis('off')

        # TransformÃ©e de Fourier pour la ROI
        plt.subplot(1, 2, 2)
        plt.imshow(np.log(1 + magnitude_spectrum), cmap='gray')
        plt.title(f"Fourier Transform for bbox {i}")
        plt.axis('off')

        plt.show()

# Charger le modÃ¨le et les poids
config_file = 'configs/s2anet/s2anet_r50_fpn_1x_dota.py'
checkpoint_file = 'checkpoints/s2anet_r50.pth'
model = init_detector(config_file, checkpoint_file, device='cuda:0')

# Charger l'image Ã  traiter
image_path = 'path_to_your_image.jpg'
image = cv2.imread(image_path)

# Faire les prÃ©dictions avec le modÃ¨le
result = inference_detector(model, image)

# Afficher les boÃ®tes englobantes avec la transformÃ©e de Fourier pour chaque ROI
plot_bboxes_with_fourier(image, result)


import cv2
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks

def extract_intensity_profile(image, bbox):
    """
    Extrait le profil d'intensitÃ© en suivant lâ€™angle donnÃ© par la bbox
    sans rotation complÃ¨te de l'image.
    """
    x, y, w, h, angle, score = bbox
    x, y, w, h = map(int, [x, y, w, h])  # Convertir en entiers

    roi = image[y:y+h, x:x+w]  # Extraire la rÃ©gion dâ€™intÃ©rÃªt
    gray_roi = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)

    # ğŸ”¹ Convertir lâ€™angle de radians â†’ degrÃ©s
    theta = angle  # âš ï¸ On garde l'angle en radians car cos/sin utilisent radians
    cos_theta, sin_theta = np.cos(theta), np.sin(theta)

    num_samples = h  # Nombre de lignes d'Ã©chantillonnage = hauteur de la bbox
    intensities = np.zeros(num_samples)

    for i in range(num_samples):
        # Calcul des coordonnÃ©es suivant l'angle dÃ©tectÃ©
        x1 = int((w / 2) + i * cos_theta)
        y1 = int((h / 2) + i * sin_theta)

        x2 = int((w / 2) - i * cos_theta)
        y2 = int((h / 2) - i * sin_theta)

        # Extraire l'intensitÃ© sur la ligne projetÃ©e
        line = cv2.line(np.zeros_like(gray_roi), (x1, y1), (x2, y2), 255, 1)
        intensities[i] = np.sum(gray_roi[line > 0])  # Somme des intensitÃ©s sur la ligne

    return intensities

def count_sheets_in_bbox(image, bbox):
    """
    Compte les feuillets dans une bbox en dÃ©tectant les pics le long de la direction des feuillets.
    """
    intensity_profile = extract_intensity_profile(image, bbox)
    
    # ğŸ”¹ DÃ©tection des pics suivant lâ€™orientation du feuillet
    peaks, _ = find_peaks(intensity_profile, distance=5, height=np.max(intensity_profile) * 0.3)

    # ğŸ”¹ Affichage
    plt.figure(figsize=(10, 4))

    plt.subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    plt.title("Image originale avec bbox")

    plt.subplot(1, 2, 2)
    plt.plot(intensity_profile)
    plt.scatter(peaks, intensity_profile[peaks], color='r')
    plt.title("Profil d'intensitÃ© avec pics dÃ©tectÃ©s")

    plt.show()

    return len(peaks)

# ğŸ”¹ Chargement de l'image et du modÃ¨le MMRotate
image_path = "path_to_your_image.jpg"
image = cv2.imread(image_path)

# RÃ©sultats de l'infÃ©rence MMRotate
result = inference_detector(model, image)

# ğŸ”¹ Boucle sur chaque bbox dÃ©tectÃ©e
for bbox in result[0]:  
    num_sheets = count_sheets_in_bbox(image, bbox)
    print(f"Nombre estimÃ© de feuillets dans la bbox {bbox[:4]} : {num_sheets}")
