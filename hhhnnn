import cv2
import numpy as np
import matplotlib.pyplot as plt
from mmrotate.apis import inference_detector, init_detector

def apply_fourier_transform(image):
    """
    Applique la transform√©e de Fourier sur une image et retourne le spectre de fr√©quence.
    :param image: Image d'entr√©e (numpy array)
    :return: Spectre de fr√©quence
    """
    # Convertir l'image en niveau de gris si n√©cessaire
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Appliquer la transform√©e de Fourier sur l'image
    f = np.fft.fft2(gray_image)
    fshift = np.fft.fftshift(f)  # D√©caler les fr√©quences basses au centre

    # Calculer la magnitude du spectre
    magnitude_spectrum = np.abs(fshift)

    return magnitude_spectrum, fshift

def plot_bboxes_with_fourier(image, result):
    """
    Affiche l'image avec les bo√Ætes englobantes d√©tect√©es et √† c√¥t√©, la transform√©e de Fourier pour chaque ROI.
    :param image: Image originale (numpy array)
    :param result: R√©sultats des d√©tections (liste de bboxes [x, y, w, h, angle, score])
    """
    # Copier l'image originale pour dessiner les bo√Ætes englobantes
    image_copy = image.copy()

    for i, bbox in enumerate(result[0]):  # result[0] est un tableau de bboxes
        x, y, w, h, angle, score = bbox

        # D√©couper la r√©gion d'int√©r√™t (ROI) de l'image
        roi = image[int(y):int(y+h), int(x):int(x+w)]

        # Appliquer la transform√©e de Fourier sur la ROI
        magnitude_spectrum, _ = apply_fourier_transform(roi)

        # Afficher l'image originale avec la bo√Æte englobante
        cv2.rectangle(image_copy, (int(x), int(y)), (int(x + w), int(y + h)), (0, 255, 0), 2)

        # Tracer l'image avec la transform√©e de Fourier
        plt.figure(figsize=(12, 6))

        # Image originale avec bbox
        plt.subplot(1, 2, 1)
        plt.imshow(cv2.cvtColor(image_copy, cv2.COLOR_BGR2RGB))
        plt.title(f"Image with bbox {i}")
        plt.axis('off')

        # Transform√©e de Fourier pour la ROI
        plt.subplot(1, 2, 2)
        plt.imshow(np.log(1 + magnitude_spectrum), cmap='gray')
        plt.title(f"Fourier Transform for bbox {i}")
        plt.axis('off')

        plt.show()

# Charger le mod√®le et les poids
config_file = 'configs/s2anet/s2anet_r50_fpn_1x_dota.py'
checkpoint_file = 'checkpoints/s2anet_r50.pth'
model = init_detector(config_file, checkpoint_file, device='cuda:0')

# Charger l'image √† traiter
image_path = 'path_to_your_image.jpg'
image = cv2.imread(image_path)

# Faire les pr√©dictions avec le mod√®le
result = inference_detector(model, image)

# Afficher les bo√Ætes englobantes avec la transform√©e de Fourier pour chaque ROI
plot_bboxes_with_fourier(image, result)


import cv2
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks

def rotate_image(image, angle):
    """ Effectue une rotation pour aligner l'axe des feuillets verticalement. """
    h, w = image.shape[:2]
    center = (w // 2, h // 2)
    
    # Matrice de rotation pour aligner la bbox selon son angle
    M = cv2.getRotationMatrix2D(center, -angle, 1.0)
    rotated = cv2.warpAffine(image, M, (w, h), flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_REFLECT)
    
    return rotated

def project_along_angle(image, angle):
    """ Projette l'intensit√© des pixels suivant l'axe des feuillets. """
    h, w = image.shape
    diag_length = int(np.sqrt(h**2 + w**2))  # Longueur diagonale pour √©viter les coupures
    
    # Cr√©er une nouvelle image avec une marge pour √©viter les artefacts
    padded = np.zeros((diag_length, diag_length), dtype=np.uint8)
    y_offset = (diag_length - h) // 2
    x_offset = (diag_length - w) // 2
    padded[y_offset:y_offset+h, x_offset:x_offset+w] = image
    
    # Faire pivoter l‚Äôimage pour aligner l‚Äôaxe des feuillets avec l‚Äôaxe Y
    rotated = rotate_image(padded, angle)
    
    # Projeter les intensit√©s le long de l'axe des feuillets (somme sur les colonnes)
    projection = np.sum(rotated, axis=0)
    
    return projection

def count_sheets_in_bbox(image, bbox):
    """
    Compte les feuillets dans une bbox en projetant les intensit√©s le long de l‚Äôorientation des feuillets.
    """
    x, y, w, h, angle, score = bbox  # R√©cup√©rer bbox et angle
    x, y, w, h = map(int, [x, y, w, h])  # Convertir en entiers
    
    roi = image[y:y+h, x:x+w]  # Extraire la r√©gion d'int√©r√™t
    gray_roi = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)

    # üîπ √âtape 1 : Projection des intensit√©s selon l'angle des feuillets
    intensity_profile = project_along_angle(gray_roi, angle)
    
    # üîπ √âtape 2 : D√©tection des pics dans la direction des feuillets
    peaks, _ = find_peaks(intensity_profile, distance=5, height=np.max(intensity_profile) * 0.3)

    # üîπ √âtape 3 : Transform√©e de Fourier pour v√©rifier la p√©riodicit√©
    f_transform = np.fft.fftshift(np.fft.fft(intensity_profile))
    freq_spectrum = np.abs(f_transform)

    # Affichage des r√©sultats
    plt.figure(figsize=(12, 4))

    plt.subplot(1, 3, 1)
    plt.imshow(gray_roi, cmap='gray')
    plt.title(f"ROI - {len(peaks)} feuillets d√©tect√©s")

    plt.subplot(1, 3, 2)
    plt.plot(intensity_profile)
    plt.scatter(peaks, intensity_profile[peaks], color='r')
    plt.title("Profil d'intensit√© projet√© avec pics")

    plt.subplot(1, 3, 3)
    plt.plot(freq_spectrum)
    plt.title("Spectre de Fourier")

    plt.show()

    return len(peaks)

# üîπ Chargement de l'image et du mod√®le MMRotate
image_path = "path_to_your_image.jpg"
image = cv2.imread(image_path)

# R√©sultats de l'inf√©rence MMRotate
result = inference_detector(model, image)

# üîπ Boucle sur chaque bbox d√©tect√©e
for bbox in result[0]:  
    num_sheets = count_sheets_in_bbox(image, bbox)
    print(f"Nombre estim√© de feuillets dans la bbox {bbox[:4]} : {num_sheets}")
