def count_black_pixels_in_bbox(image, bbox, angle):
    """
    Compter les pixels noirs dans une bbox après rotation.
    :param image: Image d'entrée (numpy array)
    :param bbox: La boîte englobante (x, y, w, h, angle, score)
    :param angle: L'angle de rotation de la bbox (en radians)
    :return: Le nombre de pixels noirs dans la bbox
    """
    x, y, w, h, angle, score = bbox

    # Assurez-vous que la largeur et la hauteur sont valides
    if w <= 0 or h <= 0:
        print(f"Invalid bounding box dimensions: w={w}, h={h}. Skipping this bbox.")
        return 0, None

    # Découper la région de la bbox dans l'image
    roi = image[int(y):int(y+h), int(x):int(x+w)]

    # Assurez-vous que roi n'est pas vide
    if roi.size == 0:
        print(f"Empty region of interest for bbox: {bbox}. Skipping this bbox.")
        return 0, None

    # Convertir l'angle de radians en degrés
    angle_degrees = angle * (180.0 / np.pi)

    # Effectuer la rotation de l'image dans la bbox
    center = (w // 2, h // 2)
    M = cv2.getRotationMatrix2D(center, angle_degrees, 1.0)

    # Si la taille de la rotation est valide
    try:
        rotated_roi = cv2.warpAffine(roi, M, (w, h))
    except cv2.error as e:
        print(f"Error in warpAffine: {e}. Skipping this bbox.")
        return 0, None

    # Convertir l'image en niveau de gris et appliquer un seuil pour les pixels noirs
    gray = cv2.cvtColor(rotated_roi, cv2.COLOR_BGR2GRAY)
    _, thresh = cv2.threshold(gray, 30, 255, cv2.THRESH_BINARY_INV)

    # Comptage des pixels noirs (lignes noires)
    black_pixels = np.sum(thresh == 255)
    
    return black_pixels, thresh