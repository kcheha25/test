import cv2
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks

def rotate_and_crop(image, bbox):
    """
    Effectue une rotation et extrait la région d'intérêt (ROI) en tenant compte de l'angle.
    """
    x, y, w, h, angle_rad, _ = bbox
    x, y, w, h = map(int, [x, y, w, h])
    
    # Convertir l'angle de radians en degrés
    angle_deg = np.degrees(angle_rad)

    # Définir la matrice de rotation
    center = (x, y)
    M = cv2.getRotationMatrix2D(center, -angle_deg, 1.0)

    # Faire pivoter l'image entière
    rotated_img = cv2.warpAffine(image, M, (image.shape[1], image.shape[0]), 
                                 flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_REFLECT)

    # Extraire la région rectangulaire après rotation
    x1, y1 = int(x - w / 2), int(y - h / 2)
    x2, y2 = int(x + w / 2), int(y + h / 2)

    roi = rotated_img[max(y1, 0):min(y2, image.shape[0]), max(x1, 0):min(x2, image.shape[1])]
    
    return roi

def enhance_contrast(image):
    """
    Améliore le contraste de l'image pour mieux distinguer les feuillets.
    """
    lab = cv2.cvtColor(image, cv2.COLOR_BGR2LAB)
    l, a, b = cv2.split(lab)
    
    # Appliquer une égalisation d'histogramme adaptative
    clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8,8))
    l = clahe.apply(l)
    
    enhanced = cv2.merge((l, a, b))
    return cv2.cvtColor(enhanced, cv2.COLOR_LAB2BGR)

def detect_sheets_hough(image):
    """
    Utilise la transformée de Hough pour détecter et relier les feuillets discontinus.
    """
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Appliquer un seuillage adaptatif
    thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, 
                                   cv2.THRESH_BINARY_INV, 11, 2)

    # Détecter les lignes avec Hough
    edges = cv2.dilate(thresh, None, iterations=2)  # Augmente les lignes fines
    lines = cv2.HoughLinesP(edges, 1, np.pi / 180, threshold=50, minLineLength=30, maxLineGap=10)

    if lines is not None:
        for line in lines:
            x1, y1, x2, y2 = line[0]
            cv2.line(image, (x1, y1), (x2, y2), (0, 255, 0), 1)

    return image

def integrate_in_orientation(image, bbox):
    """
    Projette les intensités dans la direction de l'angle de la bbox.
    """
    roi = rotate_and_crop(image, bbox)
    roi = enhance_contrast(roi)
    roi = detect_sheets_hough(roi)

    gray_roi = cv2.cvtColor(roi, cv2.COLOR_BGR2GRAY)

    # Calculer l'intégration des intensités par projection verticale
    projection = np.sum(gray_roi, axis=1)

    return projection

def count_sheets_in_bbox(image, bbox):
    """
    Compte les feuillets dans une bbox détectée par MMRotate.
    """
    intensity_profile = integrate_in_orientation(image, bbox)

    # Détection des pics dans le profil d'intensité projetée
    peaks, _ = find_peaks(intensity_profile, distance=5, height=np.max(intensity_profile) * 0.3)

    # Affichage des résultats
    plt.figure(figsize=(12, 4))

    plt.subplot(1, 2, 1)
    plt.plot(intensity_profile)
    plt.scatter(peaks, intensity_profile[peaks], color='r')
    plt.title(f"Profil d'intensité - {len(peaks)} feuillets détectés")

    roi = rotate_and_crop(image, bbox)
    roi = detect_sheets_hough(roi)
    plt.subplot(1, 2, 2)
    plt.imshow(cv2.cvtColor(roi, cv2.COLOR_BGR2RGB))
    plt.title("ROI améliorée")
    plt.show()

    return len(peaks)

# Chargement de l'image et exécution de MMRotate
image_path = "path_to_your_image.jpg"
image = cv2.imread(image_path)

# Résultats de l'inférence MMRotate
result = inference_detector(model, image)

# Boucle sur chaque bbox détectée
for bbox in result[0]:  
    num_sheets = count_sheets_in_bbox(image, bbox)
    print(f"Nombre estimé de feuillets dans la bbox {bbox[:4]} : {num_sheets}")
