import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.neighbors import NearestNeighbors

# ----------------------- #
# 1. Charger les temps depuis l'Excel
# ----------------------- #
excel_path = "composants_ref.xlsx"
df_excel = pd.read_excel(excel_path)

# Nettoyage de noms (optionnel)
df_excel['Composant'] = df_excel['Composant'].astype(str).str.strip().str.upper()

# Valeur expérimentale mesurée pour le toluène
tol_value = 85.0

# Vérification que toluene est bien présent
if not any(df_excel['Composant'].str.upper() == "TOLUENE"):
    raise ValueError("❌ 'TOLUENE' n'est pas présent dans le fichier Excel.")

# Temps de rétention de référence de toluène dans l'Excel
toluene_ref_time = df_excel[df_excel['Composant'] == "TOLUENE"]['Temps de rétention'].values[0]

# ----------------------- #
# 2. Ajustement des temps par le delta
# ----------------------- #
delta = tol_value - toluene_ref_time
df_excel['AdjustedTime'] = df_excel['Temps de rétention'] + delta

# ----------------------- #
# 3. Entraînement du modèle NearestNeighbors
# ----------------------- #
component_names = df_excel['Composant'].tolist()
X = df_excel['AdjustedTime'].values.reshape(-1, 1) / 150.0  # normalisation

nbrs = NearestNeighbors(n_neighbors=1)
nbrs.fit(X)

# ----------------------- #
# 4. Détection des pics (déjà fournis)
# ----------------------- #
# Variables supposées disponibles :
# x_full : array des temps (x)
# y_full : intensités (y)
# probs_full : probabilité d’être un pic (même longueur que x_full)

detected_peaks = []
threshold = 0.4
i = 3  # éviter les bords du signal

plt.figure(figsize=(12, 5))
plt.plot(x_full, y_full, label='Signal')
plt.title("Attribution des composants par NearestNeighbors")

while i < len(probs_full) - 3:
    if probs_full[i] > threshold:
        window = probs_full[i - 3:i + 4]
        if np.any(window > threshold):
            idx_window = np.arange(i - 3, i + 4)
            idx_max_intensity = idx_window[np.argmax(y_full[idx_window])]
            detected_peaks.append(idx_max_intensity)

            # Temps de pic détecté
            pic_time_detected = x_full[idx_max_intensity]
            pic_time_normalized = pic_time_detected / 150.0

            # Trouver le composant le plus proche
            _, indices = nbrs.kneighbors([[pic_time_normalized]])
            closest_index = indices[0][0]
            closest_component = component_names[closest_index]

            # Affichage sur le graphique
            plt.text(
                pic_time_detected,
                y_full[idx_max_intensity] + 0.02 * max(y_full),
                closest_component,
                color='red',
                fontsize=9,
                ha='center',
            )

            # Avancer après la fenêtre
            i = i + 4
        else:
            i += 1
    else:
        i += 1

plt.xlabel("Temps (min)")
plt.ylabel("Intensité")
plt.legend()
plt.grid(True)
plt.show()
