import pandas as pd
from collections import defaultdict

# Exemple
data = {
    "pics": [
        {"12.4": ["A"], "25.3": ["B"], "55.1": ["C"]},     # Chrom 0
        {"11.1": ["A"], "26.8": ["B"], "57.7": ["C"]},     # Chrom 1 (identique à 0)
        {"10.0": ["B"], "22.0": ["C"], "33.0": ["A"]},     # Chrom 2 (même noms mais ordre différent)
        {"8.0": ["A"], "30.0": ["B"]},                     # Chrom 3 (différent)
        {"15.0": ["A"], "25.0": ["B"], "55.0": ["C"]},     # Chrom 4 (identique à 0 et 1)
    ]
}
df = pd.DataFrame(data)

# Extraire les séquences ordonnées des noms de pics pour chaque chromatogramme
def extract_ordered_component_sequence(pic_dict):
    sorted_items = sorted(pic_dict.items(), key=lambda x: float(x[0]))  # trié par temps
    return tuple([v[0] for _, v in sorted_items if float(_) <= 150])  # tuple immuable

# Dictionnaire de regroupement : clé = séquence, valeur = indices
sequence_to_indices = defaultdict(list)

for idx, row in df.iterrows():
    sequence = extract_ordered_component_sequence(row["pics"])
    sequence_to_indices[sequence].append(idx)

# Affichage
print("Groupes de chromatogrammes avec même séquence ordonnée de noms de composants :\n")
for seq, indices in sequence_to_indices.items():
    if len(indices) > 1:
        print(f"Séquence {seq} → Chromatogrammes {indices}")
import pandas as pd
from collections import defaultdict
import matplotlib.pyplot as plt
import itertools

# Exemple de données simulées
data = {
    "pics": [
        {"12.4": ["A"], "25.3": ["B"], "55.1": ["C"]},     # Chrom 0
        {"11.1": ["A"], "26.8": ["B"], "57.7": ["C"]},     # Chrom 1 (même séquence)
        {"10.0": ["B"], "22.0": ["C"], "33.0": ["A"]},     # Chrom 2 (ordre différent)
        {"8.0": ["A"], "30.0": ["B"]},                     # Chrom 3 (différent)
        {"15.0": ["A"], "25.0": ["B"], "55.0": ["C"]},     # Chrom 4 (même séquence)
    ]
}
df = pd.DataFrame(data)

# 1. Extraire les séquences triées et regrouper
def extract_sequence(row):
    sorted_items = sorted(row["pics"].items(), key=lambda x: float(x[0]))
    return tuple([v[0] for _, v in sorted_items if float(_) <= 150])

# Stocker l'ordre et les temps pour chaque chromatogramme
sequence_to_chroms = defaultdict(list)
chrom_to_times = []

for idx, row in df.iterrows():
    sorted_items = sorted(row["pics"].items(), key=lambda x: float(x[0]))
    comp_names = []
    comp_times = []
    for time_str, val in sorted_items:
        t = float(time_str)
        if t <= 150:
            comp_names.append(val[0])
            comp_times.append(t)
    sequence = tuple(comp_names)
    sequence_to_chroms[sequence].append(idx)
    chrom_to_times.append(comp_times)

# 2. Pour chaque groupe ayant au moins 2 chromatogrammes
for sequence, indices in sequence_to_chroms.items():
    if len(indices) < 2:
        continue

    print(f"\nSéquence : {sequence} → Chromatogrammes : {indices}")

    # 3. Pour chaque couple possible
    for i, j in itertools.combinations(indices, 2):
        x = chrom_to_times[i]
        y = chrom_to_times[j]

        plt.figure(figsize=(5, 5))
        plt.scatter(x, y, c='blue')
        for xi, yi, label in zip(x, y, sequence):
            plt.text(xi, yi, label, fontsize=9, ha='right', va='bottom')

        plt.title(f"Nuage de points : Chrom {i} vs Chrom {j}")
        plt.xlabel(f"Temps de rétention Chrom {i}")
        plt.ylabel(f"Temps de rétention Chrom {j}")
        plt.grid(True)
        plt.axis("equal")
        plt.show()
