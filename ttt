import pandas as pd
import numpy as np
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split

# ðŸ”¹ Charger les donnÃ©es JSON en DataFrame
file_path = "chromatogrammes.json"  # Remplace par ton fichier rÃ©el
df = pd.read_json(file_path)

# ðŸ”¹ Suppression des chromatogrammes sans pics
df = df.dropna(subset=['pics'])

# ðŸ”¹ Suppression des chromatogrammes qui ne font pas exactement 71 840 points
df = df[df["x"].apply(len) == 71840]

# ðŸ”¹ CrÃ©ation de X avec 2 colonnes (temps de rÃ©tention et intensitÃ©) sous forme 2D
X = np.array([np.column_stack((row["x"], row["y"])) for _, row in df.iterrows()])

# ðŸ”¹ PrÃ©paration des labels y pour tous les pics (hauteur, bornes d'intÃ©gration, nom du composant)
y_height = []
y_bounds = []
y_component = []

# Initialiser le LabelEncoder en dehors de la boucle pour encoder tous les composants
label_encoder = LabelEncoder()

# Rassembler tous les noms de composants dans une liste globale pour les encoder
all_components = []
for _, row in df.iterrows():
    for pic_key, pic_data in row["pics"].items():
        nom_composant, _, _ = pic_data
        all_components.append(nom_composant)

# Encoder les composants
label_encoder.fit(all_components)

# Maintenant on itÃ¨re Ã  nouveau sur les chromatogrammes pour construire y_height, y_bounds, et y_component
for _, row in df.iterrows():
    # Pour chaque chromatogramme, prÃ©parer les informations des pics
    chromatogram_y_height = []
    chromatogram_y_bounds = []
    chromatogram_y_component = []
    
    for pic_key, pic_data in row["pics"].items():
        # DonnÃ©es des pics : [nom_composant, borne_avant, borne_apres]
        nom_composant, borne_avant, borne_apres = pic_data
        
        # Hauteur du pic : Prenons ici la valeur de l'intensitÃ© maximale pour simplifier
        pic_data_x = np.array(row["x"])
        pic_data_y = np.array(row["y"])
        
        # Trouver l'indice de la borne du pic
        indices_borne_avant = np.where(pic_data_x >= borne_avant)[0]
        indices_borne_apres = np.where(pic_data_x <= borne_apres)[0]
        
        # Si les bornes existent dans le chromatogramme
        if len(indices_borne_avant) > 0 and len(indices_borne_apres) > 0:
            pic_segment_x = pic_data_x[indices_borne_avant[0]:indices_borne_apres[-1]+1]
            pic_segment_y = pic_data_y[indices_borne_avant[0]:indices_borne_apres[-1]+1]
            
            # Hauteur du pic : maximum d'intensitÃ© dans cette rÃ©gion
            pic_height = np.max(pic_segment_y)
        else:
            pic_height = 0
        
        # Ajouter les informations du pic au chromatogramme
        chromatogram_y_height.append(pic_height)
        chromatogram_y_bounds.append([borne_avant, borne_apres])
        
        # Encoder le nom du composant
        chromatogram_y_component.append(label_encoder.transform([nom_composant])[0])
    
    # Pour chaque chromatogramme, stocker toutes les informations
    y_height.append(chromatogram_y_height)
    y_bounds.append(chromatogram_y_bounds)
    y_component.append(chromatogram_y_component)

# VÃ©rification des formes avant conversion en numpy
print("y_height:", len(y_height), "y_bounds:", len(y_bounds), "y_component:", len(y_component))

# ðŸ”¹ Conversion des listes en arrays numpy
y_height = np.array([np.array(chromatogram) for chromatogram in y_height], dtype=np.float32)  # Assurez-vous que c'est un tableau NumPy
y_bounds = np.array([np.array(bounds) for bounds in y_bounds], dtype=np.float32)
y_component = np.array([np.array(component) for component in y_component], dtype=np.int32)

# ðŸ”¹ Split des donnÃ©es en train et test
X_train, X_test, y_height_train, y_height_test, y_bounds_train, y_bounds_test, y_component_train, y_component_test = train_test_split(
    X, y_height, y_bounds, y_component, test_size=0.2, random_state=42)

