Développer un modèle capable de détecter les pics dans les chromatogrammes et d’identifier les composants associés.

Adaptation du modèle IPA pour la localisation des pics dans les chromatogrammes

Attribution des composants via l’algorithme Nearest Neighbors

À ma disposition, j'avais un ensemble de 453 chromatogrammes. Un premier nettoyage des données a été nécessaire : 133 chromatogrammes ne comportaient pas d'annotations de pics et ont donc été supprimés, ce qui a réduit le jeu à 320 chromatogrammes exploitables. Ensuite, le signal de chaque chromatogramme a été tronqué pour ne conserver que les points dont le temps de rétention est inférieur ou égal à 150, ce qui a permis de passer d’environ 71 000 à 45 000 points par chromatogramme. Afin de faciliter l’apprentissage, chaque chromatogramme a été découpé en segments de 1 000 points, donnant ainsi 45 segments par chromatogramme. Les données ont été normalisées en temps, mais non en intensité, car la normalisation des intensités réduisait la visibilité des pics de faible intensité. Au total, 14 400 segments ont été générés pour l'entraînement. Chaque point d’un segment est représenté par deux valeurs (temps, intensité), et pour l’étiquetage, une classification binaire a été mise en place : les points correspondant aux pics sont annotés avec la valeur 1, les autres avec la valeur 0.

🔄 Prétraitement des données
Jeu initial :
📊 453 chromatogrammes

Nettoyage :
❌ Suppression de 133 sans annotations
✅ 320 chromatogrammes restants

Tronquage du signal :
⏱️ Garde les points avec temps ≤ 150
➡️ Réduction de ~71 000 à ~45 000 points

Segmentation :
✂️ Découpe en segments de 1 000 points
➡️ 45 segments par chromatogramme
🧩 Total : 14 400 segments

Normalisation :
✅ Temps normalisé
❌ Intensité non normalisée (préservation des pics faibles)

Étiquetage (labels) :
🟢 1 si le point est un pic
⚪ 0 sinon
➡️ Classification binaire point par point


branche 1 : Complexité: Faible (opérations simples) Capturer les caractéristiques globales
branche 2: Complexité: Modérée But: Capturer les relations locales à résolution moyenne
bracnhe 3 : Complexité: Élevée But: Modéliser des motifs complexes à longue portée 
branche 4 : Complexité: Très faible  But: Fournir une transformation linéaire simple Maintenir l'information originale Éviter la perte d'information des branches complexes

Chaque x_t est un vecteur d'entrée à l'étape de temps t
Traite des séquences temporelles où chaque pas de temps a une relation avec ses voisins
Composée de deux couches LSTM parallèles:
LSTM avant (Forward): Traite la séquence du passé vers le futur (t-1 → t → t+1)
LSTM arrière (Backward): Traite la séquence du futur vers le passé (t+1 → t → t-1)
Produit la prédiction/sortie pour chaque pas de temps
Le LSTM seul présente deux faiblesses majeures :
Perte d'information progressive dans les longues séquences
Difficulté à capturer les dépendances à très longue distance
c'est pour cela j'ai ajoute un couche attention qui pèse l'importance relative de chaque élément d'entrée et Focalise les ressources computationnelles sur les éléments pertinents
#####################################################################################################################

L’architecture IPA repose sur quatre branches parallèles, chacune ayant un rôle spécifique dans l’extraction des caractéristiques du signal.
Branche 1 : faible complexité, avec des opérations simples comme le max-pooling, permettant de capturer les caractéristiques globales du signal.
Branche 2 : complexité modérée, vise à extraire des relations locales à résolution moyenne, grâce à une combinaison de convolutions.
Branche 3 : la plus complexe, composée de plusieurs couches convolutionnelles, permet de modéliser des motifs complexes à longue portée.
Branche 4 : très simple, effectue une transformation linéaire pour préserver l'information originale et éviter les pertes dues aux autres branches plus complexes.

Après concaténation des sorties de ces quatre branches, un BiLSTM est ajouté pour traiter la séquence temporelle :
il prend en entrée les caractéristiques de chaque point (chaque 
𝑥
𝑡
x 
t
​
  étant un vecteur à l'instant 
𝑡
t).
Le BiLSTM est composé de deux LSTM parallèles : un avant (passé → futur) et un arrière (futur → passé), permettant de modéliser les dépendances dans les deux directions. Cependant, seul, le LSTM peut perdre de l'information sur les longues séquences et peine à capturer les dépendances à très longue distance.

Pour pallier ces limites, une couche d’attention est ajoutée afin de pondérer l’importance relative de chaque point de la séquence, permettant au modèle de focaliser son attention sur les éléments pertinents pour une meilleure prédiction.

#############################################################

La Focal Loss binaire, introduite par Lin et al. (2017), est :

FL
(
𝑝
𝑡
)
=
−
𝛼
𝑡
⋅
(
1
−
𝑝
𝑡
)
𝛾
⋅
log
⁡
(
𝑝
𝑡
)
FL(p 
t
​
 )=−α 
t
​
 ⋅(1−p 
t
​
 ) 
γ
 ⋅log(p 
t
​
 )
🧩 Où :
𝑝
𝑡
p 
t
​
  est la probabilité prédite pour la classe correcte (celle donnée par le label) :

𝑝
𝑡
=
{
𝑝
si 
𝑦
=
1
1
−
𝑝
si 
𝑦
=
0
p 
t
​
 ={ 
p
1−p
​
  
si y=1
si y=0
​
 
log
⁡
(
𝑝
𝑡
)
log(p 
t
​
 ) est la perte classique (entropie croisée).

(
1
−
𝑝
𝑡
)
𝛾
(1−p 
t
​
 ) 
γ
  est le modulateur qui réduit l’impact des prédictions correctes :

Si 
𝑝
𝑡
p 
t
​
  est proche de 1 (prédiction correcte), alors 
(
1
−
𝑝
𝑡
)
𝛾
(1−p 
t
​
 ) 
γ
  est proche de 0.

Si 
𝑝
𝑡
p 
t
​
  est proche de 0 (mauvaise prédiction), le terme est proche de 1.

𝛾
≥
0
γ≥0 est l’exposant de focalisation :

Contrôle à quel point on ignore les exemples faciles.

Plus 
𝛾
γ est grand, plus on se concentre sur les exemples mal classés.

𝛼
𝑡
∈
[
0
,
1
]
α 
t
​
 ∈[0,1] est un poids pour chaque classe :

𝛼
𝑡
=
{
𝛼
si 
𝑦
=
1
1
−
𝛼
si 
𝑦
=
0
α 
t
​
 ={ 
α
1−α
​
  
si y=1
si y=0
​

Récupérer le temps de rétention de chaque pic détecté par IPA 
Collecter les temps de rétention de tous les pics en notre possession.
Entraîner un NearestNeighbors sur ces temps de rétention
Recherche avec NearestNeighbors
Récupérer l’indice du plus proche voisin dans les données d’entraînement.
Assigner au pic IPA le nom du composant du plus proche voisin.