from detectron2.engine import DefaultPredictor
from detectron2.config import get_cfg
from detectron2 import model_zoo
import cv2

# Configuration du modèle
cfg = get_cfg()
cfg.merge_from_file(model_zoo.get_config_file(
    "COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x.yaml"
))
cfg.MODEL.ROI_HEADS.NUM_CLASSES = 3   # tes 3 classes
cfg.MODEL.WEIGHTS = "model_final_3classes.pth"  # ton modèle entraîné
cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.5

predictor = DefaultPredictor(cfg)

image = cv2.imread("image.jpg")
outputs = predictor(image)

instances = outputs["instances"].to("cpu")
pred_classes = instances.pred_classes.numpy()
masks = instances.pred_masks.numpy()

from collections import defaultdict

results = defaultdict(lambda: {"T0": [], "T1": [], "T2": []})

for cls_id, mask in zip(pred_classes, masks):
    T0, T1, T2 = calc_tensors_from_mask(mask)
    results[cls_id]["T0"].append(T0)
    results[cls_id]["T1"].append(T1)
    results[cls_id]["T2"].append(T2)

# Moyenne par classe
mean_results = {}
for cls_id, vals in results.items():
    mean_results[cls_id] = {
        "T0": np.mean(vals["T0"]),
        "T1": np.mean(vals["T1"], axis=0),
        "T2": np.mean(vals["T2"], axis=0)
    }

print(mean_results)

import numpy as np
import cv2

def calc_tensors_from_mask(mask, d=5):
    """
    Calcule T0, T1, T2 pour un masque binaire selon la méthode stéréologique,
    avec demi-droites horizontales espacées verticalement par d, 
    selon l'ordre d'alternance spécifique demandé,
    et tracées uniquement aux niveaux verticaux présents dans la particule.
    """
    mask = mask.astype(np.uint8)
    H, W = mask.shape

    ys, xs = np.nonzero(mask)
    if len(xs) == 0:
        return 0, np.zeros(3), np.zeros((3, 3))

    xO = xs.mean()
    yO = ys.mean()

    y_min = ys.min()
    y_max = ys.max()

    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    contour_points = set(tuple(pt[0]) for c in contours for pt in c)

    T0 = 0.0
    T1 = np.zeros(3)
    T2 = np.zeros((3, 3))

    max_offset = max(yO - y_min, y_max - yO)
    max_steps = int(np.ceil(max_offset / d))

    y_offsets = []
    directions = []

    for i in range(1, max_steps + 1):
        for sign in [1, -1]:
            y_candidate = int(round(yO + sign * i * d))
            if y_candidate < y_min or y_candidate > y_max:
                continue
            if i % 2 == 1:
                # i impair : y0 + i*d vers droite, y0 - i*d vers gauche
                if sign == 1:
                    direction = 'right'
                else:
                    direction = 'left'
            else:
                # i pair : y0 + i*d vers gauche, y0 - i*d vers droite
                if sign == 1:
                    direction = 'left'
                else:
                    direction = 'right'

            y_offsets.append(sign * i * d)
            directions.append(direction)

    for offset, direction in zip(y_offsets, directions):
        y = int(round(yO + offset))
        if y < 0 or y >= H:
            continue

        intersections = []

        if direction == 'right':
            for x in range(int(np.ceil(xO)) + 1, W):
                if (x, y) in contour_points:
                    intersections.append((x, y))
        else:  # gauche
            for x in range(int(np.floor(xO)) - 1, -1, -1):
                if (x, y) in contour_points:
                    intersections.append((x, y))

        if not intersections:
            continue

        intersections_sorted = sorted(intersections,
                                      key=lambda p: np.hypot(p[0] - xO, p[1] - yO),
                                      reverse=True)

        sign = 1
        for (x_int, y_int) in intersections_sorted:
            xr = x_int - xO
            yr = y_int - yO

            g0 = np.pi * d * xr ** 2
            g1 = np.array([0, np.pi * d * xr ** 2 * yr, 0])
            g2 = np.array([
                [np.pi / 8 * d * xr ** 4, 0, 0],
                [0, np.pi / 2 * d * xr ** 2 * yr ** 2, 0],
                [0, 0, np.pi / 8 * d * xr ** 4]
            ])

            T0 += sign * g0
            T1 += sign * g1
            T2 += sign * g2

            sign *= -1

    return T0, T1, T2



import numpy as np
from collections import defaultdict
import cv2

def extract_area(mask):
    return np.count_nonzero(mask)

def subclass_label(cls, part):
    return f"{cls}_{part}"

# Séparer les indices par classe
indices_0 = [i for i, c in enumerate(pred_classes) if c == 0]
indices_1 = [i for i, c in enumerate(pred_classes) if c == 1]
indices_2 = [i for i, c in enumerate(pred_classes) if c == 2]

# Calcul des aires pour classes 0 et 1
areas_0 = np.array([extract_area(masks[i]) for i in indices_0])
areas_1 = np.array([extract_area(masks[i]) for i in indices_1])

# Calcul des médianes
median_0 = np.median(areas_0) if len(areas_0) > 0 else 0
median_1 = np.median(areas_1) if len(areas_1) > 0 else 0

results = defaultdict(lambda: {"T0": [], "T1": [], "T2": []})

# Classe 0 : division selon médiane
for i, mask_idx in enumerate(indices_0):
    area = areas_0[i]
    part = 1 if area <= median_0 else 2
    label = subclass_label(0, part)
    T0, T1, T2 = calc_tensors_from_mask(masks[mask_idx])
    results[label]["T0"].append(T0)
    results[label]["T1"].append(T1)
    results[label]["T2"].append(T2)

# Classe 1 : division selon médiane
for i, mask_idx in enumerate(indices_1):
    area = areas_1[i]
    part = 1 if area <= median_1 else 2
    label = subclass_label(1, part)
    T0, T1, T2 = calc_tensors_from_mask(masks[mask_idx])
    results[label]["T0"].append(T0)
    results[label]["T1"].append(T1)
    results[label]["T2"].append(T2)

# Classe 2 inchangée
for mask_idx in indices_2:
    label = "2"
    T0, T1, T2 = calc_tensors_from_mask(masks[mask_idx])
    results[label]["T0"].append(T0)
    results[label]["T1"].append(T1)
    results[label]["T2"].append(T2)

# Moyenne par sous-classe
mean_results = {}
for label, vals in results.items():
    mean_results[label] = {
        "T0": np.mean(vals["T0"]),
        "T1": np.mean(vals["T1"], axis=0),
        "T2": np.mean(vals["T2"], axis=0)
    }

print(mean_results)


import numpy as np
import cv2
import math

# ---- Ta fonction calc_tensors_from_mask ----
def calc_tensors_from_mask(mask, d=5):
    mask = mask.astype(np.uint8)
    H, W = mask.shape

    ys, xs = np.nonzero(mask)
    if len(xs) == 0:
        return 0, np.zeros(3), np.zeros((3, 3))

    xO = xs.mean()
    yO = ys.mean()

    y_min = ys.min()
    y_max = ys.max()

    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    contour_points = set(tuple(pt[0]) for c in contours for pt in c)

    T0 = 0.0
    T1 = np.zeros(3)
    T2 = np.zeros((3, 3))

    max_offset = max(yO - y_min, y_max - yO)
    max_steps = int(np.ceil(max_offset / d))

    y_offsets = []
    directions = []

    for i in range(1, max_steps + 1):
        for sign in [1, -1]:
            y_candidate = int(round(yO + sign * i * d))
            if y_candidate < y_min or y_candidate > y_max:
                continue
            if i % 2 == 1:
                if sign == 1:
                    direction = 'right'
                else:
                    direction = 'left'
            else:
                if sign == 1:
                    direction = 'left'
                else:
                    direction = 'right'

            y_offsets.append(sign * i * d)
            directions.append(direction)

    for offset, direction in zip(y_offsets, directions):
        y = int(round(yO + offset))
        if y < 0 or y >= H:
            continue

        intersections = []
        if direction == 'right':
            for x in range(int(np.ceil(xO)) + 1, W):
                if (x, y) in contour_points:
                    intersections.append((x, y))
        else:
            for x in range(int(np.floor(xO)) - 1, -1, -1):
                if (x, y) in contour_points:
                    intersections.append((x, y))

        if not intersections:
            continue

        intersections_sorted = sorted(
            intersections,
            key=lambda p: np.hypot(p[0] - xO, p[1] - yO),
            reverse=True
        )

        sign = 1
        for (x_int, y_int) in intersections_sorted:
            xr = x_int - xO
            yr = y_int - yO

            g0 = np.pi * d * xr ** 2
            g1 = np.array([0, np.pi * d * xr ** 2 * yr, 0])
            g2 = np.array([
                [np.pi / 8 * d * xr ** 4, 0, 0],
                [0, np.pi / 2 * d * xr ** 2 * yr ** 2, 0],
                [0, 0, np.pi / 8 * d * xr ** 4]
            ])

            T0 += sign * g0
            T1 += sign * g1
            T2 += sign * g2

            sign *= -1

    return T0, T1, T2

# ---- Génération d'une ellipse 2D ----
def generate_ellipse_mask(a, b, img_size=500):
    """
    Génère une ellipse verticale (a = rayon horizontal, b = rayon vertical)
    centrée dans une image binaire.
    """
    mask = np.zeros((img_size, img_size), dtype=np.uint8)
    center = (img_size // 2, img_size // 2)
    axes = (int(a), int(b))
    cv2.ellipse(mask, center, axes, angle=0, startAngle=0, endAngle=360, color=1, thickness=-1)
    return mask

# ---- Paramètres de l'ellipsoïde ----
a_real = 60   # rayon horizontal (x)
b_real = 80   # rayon vertical (y)
c_real = 50   # rayon profondeur (z)

# Volume réel de l’ellipsoïde
volume_real = (4/3) * math.pi * a_real * b_real * c_real
print(f"Volume réel ellipsoïde = {volume_real:.2f} pixels³ (unités arbitraires)")

# Générer la coupe verticale (ellipse a x b)
mask = generate_ellipse_mask(a_real, b_real)

# ---- Appliquer la méthode stéréologique ----
T0, T1, T2 = calc_tensors_from_mask(mask, d=5)

# Ici, on suppose que T0 correspond à une estimation liée au volume
# mais comme ton algorithme n'est pas directement un calcul de volume pur,
# il faudrait voir le facteur de conversion adapté.
print(f"T0 estimé = {T0:.2f}")
print(f"T1 estimé = {T1}")
print(f"T2 estimé =\n{T2}")


import os
import cv2
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt

from detectron2.engine import DefaultPredictor
from detectron2.config import get_cfg
from detectron2.data import MetadataCatalog

# === Paramètres ===
image_path = "chemin/vers/image_complete.png"  # À modifier
config_path = "chemin/vers/config.yaml"         # À modifier
weights_path = "chemin/vers/model_final.pth"    # À modifier

patch_size = (512, 350)
resized_size = (512, 400)
overlap = 50

# === Initialisation du modèle Detectron2 ===
cfg = get_cfg()
cfg.merge_from_file(config_path)
cfg.MODEL.WEIGHTS = weights_path
cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.5
predictor = DefaultPredictor(cfg)
metadata = MetadataCatalog.get(cfg.DATASETS.TRAIN[0])

# === Charger l’image ===
image = Image.open(image_path).convert("RGB")
width, height = image.size
full_image_np = np.array(image)
output_image = full_image_np.copy()

# Masque pour objets pris en compte
class_map = np.full((height, width), fill_value=255, dtype=np.uint8)  # 255 = fond
score_map = np.zeros((height, width), dtype=np.float32)  # score max par pixel

# === Découpage en patchs et inférence ===
pw, ph = patch_size

for y in range(0, height, ph - overlap):
    for x in range(0, width, pw - overlap):
        crop_w = min(pw + (overlap if x + pw < width else 0), width - x)
        crop_h = min(ph + (overlap if y + ph < height else 0), height - y)

        # Extraction patch + redimensionnement
        patch = image.crop((x, y, x + crop_w, y + crop_h)).resize(resized_size)
        patch_np = np.array(patch)

        outputs = predictor(patch_np)
        instances = outputs["instances"].to("cpu")

        for i in range(len(instances)):
            class_id = int(instances.pred_classes[i])
            score = float(instances.scores[i])
            mask = instances.pred_masks[i].numpy().astype(np.uint8) * 255

            # Remettre le masque à la taille du crop
            mask_resized = cv2.resize(mask, (crop_w, crop_h), interpolation=cv2.INTER_NEAREST)

            # Position de l’objet dans l’image complète
            y1, y2 = y, y + crop_h
            x1, x2 = x, x + crop_w

            # Indices où le masque est présent
            mask_pixels = mask_resized > 127

            # Mise à jour seulement si score supérieur au score déjà enregistré
            update_pixels = mask_pixels & (score > score_map[y1:y2, x1:x2])
            class_map[y1:y2, x1:x2][update_pixels] = class_id
            score_map[y1:y2, x1:x2][update_pixels] = score

# ==========================================================
# Interface Tkinter pour sélectionner les zones
# ==========================================================
import tkinter as tk
from PIL import ImageTk

polygon_points = []
all_polygons = []

def on_click(event):
    x, y = event.x, event.y
    polygon_points.append((x, y))
    r = 2
    canvas.create_oval(x - r, y - r, x + r, y + r, fill='red')

def close_polygon():
    global polygon_points
    if len(polygon_points) >= 3:
        all_polygons.append(polygon_points[:])
        canvas.create_polygon(polygon_points, outline='green', fill='', width=2)
        polygon_points = []

def finish():
    root.destroy()

# Création interface
root = tk.Tk()
root.title("Dessine les polygones (clic: points, bouton: fermer)")

image_tk = ImageTk.PhotoImage(Image.fromarray(output_image))
canvas = tk.Canvas(root, width=width, height=height)
canvas.pack()
canvas.create_image(0, 0, anchor=tk.NW, image=image_tk)
canvas.bind("<Button-1>", on_click)

btn_frame = tk.Frame(root)
btn_frame.pack()
tk.Button(btn_frame, text="Fermer polygone", command=close_polygon).pack(side=tk.LEFT, padx=10)
tk.Button(btn_frame, text="Terminer", command=finish).pack(side=tk.RIGHT, padx=10)

root.mainloop()

# === Création du masque à partir des polygones dessinés ===
zone_mask = np.zeros((height, width), dtype=np.uint8)
for poly in all_polygons:
    cv2.fillPoly(zone_mask, [np.array(poly, dtype=np.int32)], 255)

# === Calcul du pourcentage d’occupation par classe ===
total_pixels = np.sum(zone_mask > 0)
fractions = {}

for class_id in np.unique(class_map[class_map != 255]):
    pixels = np.sum((class_map == class_id) & (zone_mask > 0))
    fractions[class_id] = round(100 * pixels / total_pixels, 2) if total_pixels else 0

# === Affichage des résultats ===
print("Fraction d’occupation (à l’intérieur des polygones dessinés) :")
for cid, perc in fractions.items():
    print(f"  Classe {cid} : {perc} %")
