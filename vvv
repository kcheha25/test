from detectron2.engine import DefaultPredictor
from detectron2.config import get_cfg
from detectron2 import model_zoo
import cv2

# Configuration du modèle
cfg = get_cfg()
cfg.merge_from_file(model_zoo.get_config_file(
    "COCO-InstanceSegmentation/mask_rcnn_R_50_FPN_3x.yaml"
))
cfg.MODEL.ROI_HEADS.NUM_CLASSES = 3   # tes 3 classes
cfg.MODEL.WEIGHTS = "model_final_3classes.pth"  # ton modèle entraîné
cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.5

predictor = DefaultPredictor(cfg)

image = cv2.imread("image.jpg")
outputs = predictor(image)

instances = outputs["instances"].to("cpu")
pred_classes = instances.pred_classes.numpy()
masks = instances.pred_masks.numpy()

from collections import defaultdict

results = defaultdict(lambda: {"T0": [], "T1": [], "T2": []})

for cls_id, mask in zip(pred_classes, masks):
    T0, T1, T2 = calc_tensors_from_mask(mask)
    results[cls_id]["T0"].append(T0)
    results[cls_id]["T1"].append(T1)
    results[cls_id]["T2"].append(T2)

# Moyenne par classe
mean_results = {}
for cls_id, vals in results.items():
    mean_results[cls_id] = {
        "T0": np.mean(vals["T0"]),
        "T1": np.mean(vals["T1"], axis=0),
        "T2": np.mean(vals["T2"], axis=0)
    }

print(mean_results)

import numpy as np
import cv2

def calc_tensors_from_mask(mask, d=5):
    """
    Calcule T0, T1, T2 pour un masque binaire selon la méthode stéréologique,
    avec demi-droites horizontales espacées verticalement par d, 
    selon l'ordre d'alternance spécifique demandé,
    et tracées uniquement aux niveaux verticaux présents dans la particule.
    """
    mask = mask.astype(np.uint8)
    H, W = mask.shape

    ys, xs = np.nonzero(mask)
    if len(xs) == 0:
        return 0, np.zeros(3), np.zeros((3, 3))

    xO = xs.mean()
    yO = ys.mean()

    y_min = ys.min()
    y_max = ys.max()

    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    contour_points = set(tuple(pt[0]) for c in contours for pt in c)

    T0 = 0.0
    T1 = np.zeros(3)
    T2 = np.zeros((3, 3))

    max_offset = max(yO - y_min, y_max - yO)
    max_steps = int(np.ceil(max_offset / d))

    y_offsets = []
    directions = []

    for i in range(1, max_steps + 1):
        for sign in [1, -1]:
            y_candidate = int(round(yO + sign * i * d))
            if y_candidate < y_min or y_candidate > y_max:
                continue
            if i % 2 == 1:
                # i impair : y0 + i*d vers droite, y0 - i*d vers gauche
                if sign == 1:
                    direction = 'right'
                else:
                    direction = 'left'
            else:
                # i pair : y0 + i*d vers gauche, y0 - i*d vers droite
                if sign == 1:
                    direction = 'left'
                else:
                    direction = 'right'

            y_offsets.append(sign * i * d)
            directions.append(direction)

    for offset, direction in zip(y_offsets, directions):
        y = int(round(yO + offset))
        if y < 0 or y >= H:
            continue

        intersections = []

        if direction == 'right':
            for x in range(int(np.ceil(xO)) + 1, W):
                if (x, y) in contour_points:
                    intersections.append((x, y))
        else:  # gauche
            for x in range(int(np.floor(xO)) - 1, -1, -1):
                if (x, y) in contour_points:
                    intersections.append((x, y))

        if not intersections:
            continue

        intersections_sorted = sorted(intersections,
                                      key=lambda p: np.hypot(p[0] - xO, p[1] - yO),
                                      reverse=True)

        sign = 1
        for (x_int, y_int) in intersections_sorted:
            xr = x_int - xO
            yr = y_int - yO

            g0 = np.pi * d * xr ** 2
            g1 = np.array([0, np.pi * d * xr ** 2 * yr, 0])
            g2 = np.array([
                [np.pi / 8 * d * xr ** 4, 0, 0],
                [0, np.pi / 2 * d * xr ** 2 * yr ** 2, 0],
                [0, 0, np.pi / 8 * d * xr ** 4]
            ])

            T0 += sign * g0
            T1 += sign * g1
            T2 += sign * g2

            sign *= -1

    return T0, T1, T2



import numpy as np
from collections import defaultdict
import cv2

def extract_area(mask):
    return np.count_nonzero(mask)

def subclass_label(cls, part):
    return f"{cls}_{part}"

# Séparer les indices par classe
indices_0 = [i for i, c in enumerate(pred_classes) if c == 0]
indices_1 = [i for i, c in enumerate(pred_classes) if c == 1]
indices_2 = [i for i, c in enumerate(pred_classes) if c == 2]

# Calcul des aires pour classes 0 et 1
areas_0 = np.array([extract_area(masks[i]) for i in indices_0])
areas_1 = np.array([extract_area(masks[i]) for i in indices_1])

# Calcul des médianes
median_0 = np.median(areas_0) if len(areas_0) > 0 else 0
median_1 = np.median(areas_1) if len(areas_1) > 0 else 0

results = defaultdict(lambda: {"T0": [], "T1": [], "T2": []})

# Classe 0 : division selon médiane
for i, mask_idx in enumerate(indices_0):
    area = areas_0[i]
    part = 1 if area <= median_0 else 2
    label = subclass_label(0, part)
    T0, T1, T2 = calc_tensors_from_mask(masks[mask_idx])
    results[label]["T0"].append(T0)
    results[label]["T1"].append(T1)
    results[label]["T2"].append(T2)

# Classe 1 : division selon médiane
for i, mask_idx in enumerate(indices_1):
    area = areas_1[i]
    part = 1 if area <= median_1 else 2
    label = subclass_label(1, part)
    T0, T1, T2 = calc_tensors_from_mask(masks[mask_idx])
    results[label]["T0"].append(T0)
    results[label]["T1"].append(T1)
    results[label]["T2"].append(T2)

# Classe 2 inchangée
for mask_idx in indices_2:
    label = "2"
    T0, T1, T2 = calc_tensors_from_mask(masks[mask_idx])
    results[label]["T0"].append(T0)
    results[label]["T1"].append(T1)
    results[label]["T2"].append(T2)

# Moyenne par sous-classe
mean_results = {}
for label, vals in results.items():
    mean_results[label] = {
        "T0": np.mean(vals["T0"]),
        "T1": np.mean(vals["T1"], axis=0),
        "T2": np.mean(vals["T2"], axis=0)
    }

print(mean_results)


import numpy as np
import cv2
import math
import numpy as np
import random

# ---- Ta fonction calc_tensors_from_mask ----
def calc_tensors_from_mask(mask, d=5):
    mask = mask.astype(np.uint8)
    H, W = mask.shape

    ys, xs = np.nonzero(mask)
    if len(xs) == 0:
        return 0, np.zeros(3), np.zeros((3, 3))

    xO = xs.mean()
    yO = ys.mean()

    y_min = ys.min()
    y_max = ys.max()

    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    contour_points = set(tuple(pt[0]) for c in contours for pt in c)

    T0 = 0.0
    T1 = np.zeros(3)
    T2 = np.zeros((3, 3))

    max_offset = max(yO - y_min, y_max - yO)
    max_steps = int(np.ceil(max_offset / d))

    y_offsets = []
    directions = []

    for i in range(1, max_steps + 1):
        for sign in [1, -1]:
            y_candidate = int(round(yO + sign * i * d))
            if y_candidate < y_min or y_candidate > y_max:
                continue
            if i % 2 == 1:
                if sign == 1:
                    direction = 'right'
                else:
                    direction = 'left'
            else:
                if sign == 1:
                    direction = 'left'
                else:
                    direction = 'right'

            y_offsets.append(sign * i * d)
            directions.append(direction)

    for offset, direction in zip(y_offsets, directions):
        y = int(round(yO + offset))
        if y < 0 or y >= H:
            continue

        intersections = []
        if direction == 'right':
            for x in range(int(np.ceil(xO)) + 1, W):
                if (x, y) in contour_points:
                    intersections.append((x, y))
        else:
            for x in range(int(np.floor(xO)) - 1, -1, -1):
                if (x, y) in contour_points:
                    intersections.append((x, y))

        if not intersections:
            continue

        intersections_sorted = sorted(
            intersections,
            key=lambda p: np.hypot(p[0] - xO, p[1] - yO),
            reverse=True
        )

        sign = 1
        for (x_int, y_int) in intersections_sorted:
            xr = x_int - xO
            yr = y_int - yO

            g0 = np.pi * d * xr ** 2
            g1 = np.array([0, np.pi * d * xr ** 2 * yr, 0])
            g2 = np.array([
                [np.pi / 8 * d * xr ** 4, 0, 0],
                [0, np.pi / 2 * d * xr ** 2 * yr ** 2, 0],
                [0, 0, np.pi / 8 * d * xr ** 4]
            ])

            T0 += sign * g0
            T1 += sign * g1
            T2 += sign * g2

            sign *= -1

    return T0, T1, T2


# ---- Génération d'une ellipse 2D ----
def draw_ellipse_on_mask(mask, a, b, center):
    cv2.ellipse(mask, center, (int(a), int(b)), angle=0, startAngle=0, endAngle=360, color=1, thickness=-1)


# ---- Simulation de plusieurs ellipses ----
img_size = 800
mask_total = np.zeros((img_size, img_size), dtype=np.uint8)

N = 10  # nombre d'ellipses
volumes_real = []
volumes_est = []

for _ in range(N):
    a_real = random.randint(30, 80)  # rayon horizontal
    b_real = random.randint(30, 90)  # rayon vertical
    c_real = random.randint(20, 70)  # rayon profondeur

    # Volume réel de l’ellipsoïde
    volume_real = (4/3) * math.pi * a_real * b_real * c_real
    volumes_real.append(volume_real)

    # Choisir position aléatoire sur l'image
    cx = random.randint(a_real+5, img_size-a_real-5)
    cy = random.randint(b_real+5, img_size-b_real-5)

    draw_ellipse_on_mask(mask_total, a_real, b_real, (cx, cy))

# ---- Extraire chaque ellipse individuellement ----
contours, _ = cv2.findContours(mask_total, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

for cnt in contours:
    # Créer un masque individuel
    mask_single = np.zeros_like(mask_total)
    cv2.drawContours(mask_single, [cnt], -1, 1, -1)

    # Calculer T0
    T0, _, _ = calc_tensors_from_mask(mask_single, d=5)
    volumes_est.append(T0)

# ---- Comparaison ----
vol_mean_real = np.mean(volumes_real)
vol_mean_est = np.mean(volumes_est)
err_rel = (vol_mean_est - vol_mean_real) / vol_mean_real * 100

print(f"Volume moyen réel   = {vol_mean_real:.2f}")
print(f"Volume moyen estimé = {vol_mean_est:.2f}")
print(f"Erreur relative moyenne = {err_rel:.2f} %")

