import cv2
import numpy as np

# 1. Charger l’image en niveaux de gris
img = cv2.imread('bille.png', cv2.IMREAD_GRAYSCALE)

# 2. Flouter légèrement
blur = cv2.GaussianBlur(img, (5, 5), 0)

# 3. Seuillage avec Otsu (bille claire = blanc, fond = noir)
_, binary = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

# 4. Inverser : la bille devient noire, fond = blanc (facilite le remplissage)
binary_inv = cv2.bitwise_not(binary)

# 5. Remplir les zones connectées au fond (flood fill)
floodfill = binary_inv.copy()
h, w = floodfill.shape[:2]
mask = np.zeros((h + 2, w + 2), np.uint8)

# Remplir depuis un pixel du fond (coin par ex.)
cv2.floodFill(floodfill, mask, (0, 0), 255)

# 6. Trou noir = fond, on récupère la bille entière : inversion + OU logique
bille_filled = cv2.bitwise_not(floodfill) | binary_inv

# 7. Détection des contours sur l’image nettoyée
contours, _ = cv2.findContours(bille_filled, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# 8. Filtrer contours avec taille a >= 100
filtered = [cnt for cnt in contours if cnt.shape[0] >= 100]

# 9. Sélection des 1 ou 2 plus gros
selected = sorted(filtered, key=cv2.contourArea, reverse=True)[:2]

# 10. Affichage
output = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)
for c in selected:
    cv2.drawContours(output, [c], -1, (0, 0, 255), 2)

cv2.imshow("Bille avec trous latéraux détectée", output)
cv2.waitKey(0)
cv2.destroyAllWindows()


import os
import cv2
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt

from detectron2.engine import DefaultPredictor
from detectron2.config import get_cfg
from detectron2.data import MetadataCatalog

# === Paramètres ===
image_path = "chemin/vers/image_complete.png"
patch_size = (512, 350)
resized_size = (512, 400)
overlap = 50

# === Initialiser le modèle Detectron2 ===
cfg = get_cfg()
cfg.merge_from_file("chemin/vers/config.yaml")
cfg.MODEL.WEIGHTS = "chemin/vers/model_final.pth"
cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.5
predictor = DefaultPredictor(cfg)
metadata = MetadataCatalog.get(cfg.DATASETS.TRAIN[0])

# === Couleurs des classes (à adapter si tu as plus de 2 classes) ===
class_colors = {
    0: (255, 0, 0),     # Classe 0 : Rouge (zones creuses)
    1: (0, 255, 0),     # Classe 1 : Vert (zones denses)
}

# === Charger l'image complète ===
image = Image.open(image_path).convert("RGB")
width, height = image.size
full_image_np = np.array(image)
output_image = full_image_np.copy()

# === Générer les patchs et lancer l'inférence ===
patch_id = 0
pw, ph = patch_size
rw, rh = resized_size

for y in range(0, height, ph - overlap):
    for x in range(0, width, pw - overlap):
        # Taille dynamique du crop
        if patch_id == 0:
            crop_w, crop_h = pw, ph
        elif patch_id == 1:
            crop_w, crop_h = pw + overlap, ph
        elif patch_id == 2:
            crop_w, crop_h = pw, ph + overlap
        else:
            crop_w, crop_h = pw + overlap, ph + overlap

        crop_w = min(crop_w, width - x)
        crop_h = min(crop_h, height - y)

        # Extraction et resizing du patch
        patch = image.crop((x, y, x + crop_w, y + crop_h)).resize(resized_size)
        patch_np = np.array(patch)

        outputs = predictor(patch_np)
        instances = outputs["instances"].to("cpu")

        # Créer un masque vide (resized_size)
        mask_overlay = np.zeros((resized_size[1], resized_size[0], 3), dtype=np.uint8)

        # Appliquer chaque masque avec une couleur selon la classe
        for i in range(len(instances)):
            mask = instances.pred_masks[i].numpy()
            class_id = int(instances.pred_classes[i])
            color = class_colors.get(class_id, (255, 255, 255))

            # Colorer les pixels du masque
            colored_mask = np.zeros_like(mask_overlay)
            for c in range(3):
                colored_mask[:, :, c] = mask.astype(np.uint8) * color[c]

            # Ajouter le masque au résultat final (superposition)
            mask_overlay = cv2.addWeighted(mask_overlay, 1.0, colored_mask, 0.5, 0)

        # Resize le masque coloré à la taille originale du patch
        mask_resized = cv2.resize(mask_overlay, (crop_w, crop_h))

        # Fusionner avec l'image finale (superposition 50%)
        output_image[y:y + crop_h, x:x + crop_w] = cv2.addWeighted(
            output_image[y:y + crop_h, x:x + crop_w], 0.5, mask_resized, 0.5, 0
        )

        patch_id += 1

# === Affichage final avec Matplotlib ===
plt.figure(figsize=(10, 8))
plt.imshow(cv2.cvtColor(output_image, cv2.COLOR_BGR2RGB))
plt.title("Masques colorés (sans BBox ni Labels)")
plt.axis('off')
plt.tight_layout()
plt.show()

# Pour sauvegarder :
# cv2.imwrite("output_mask_overlay.png", output_image)
