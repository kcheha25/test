import cv2
import numpy as np
import matplotlib.pyplot as plt
from detectron2.utils.visualizer import Visualizer
import matplotlib as mpl

# Fonction de calcul de l'angle d'orientation d'un rectangle
def get_angle(x1, y1, x2, y2):
    from math import atan2, degrees
    angle = atan2(y2 - y1, x2 - x1)
    return degrees(angle)

# Vérifier si deux feuillets sont proches et ont des orientations similaires
def are_feuillets_similar(feuillet1, feuillet2, distance_threshold=50, angle_threshold=15):
    # Distance euclidienne entre les centres des feuillets
    distance_position = np.sqrt((feuillet1[0] - feuillet2[0])**2 + (feuillet1[1] - feuillet2[1])**2)
    
    # Différence d'orientation (en degrés)
    distance_orientation = abs(feuillet1[2] - feuillet2[2])
    
    # Vérifier si la distance et l'orientation sont suffisamment proches
    if distance_position < distance_threshold and distance_orientation < angle_threshold:
        return True
    return False

# Extraire les informations des feuillets détectés
def extract_feuillets(outputs):
    instances = outputs['instances']
    feuillets = []
    
    # Récupérer les coordonnées du centre de chaque feuillet et son orientation (angle)
    for i in range(len(instances)):
        bbox = instances[i].pred_boxes.tensor.cpu().numpy().flatten()  # Boîte englobante (sur CPU)
        center_x, center_y = (bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2  # Centre du rectangle
        angle = get_angle(bbox[0], bbox[1], bbox[2], bbox[3])  # Angle d'orientation
        feuillets.append((center_x, center_y, angle))
    
    return feuillets

# Regrouper les feuillets par proximité et orientation
def group_feuillets(feuillets):
    groups = []
    assigned_groups = []
    
    for i, feuillet1 in enumerate(feuillets):
        if i in assigned_groups:
            continue
        
        # Créer un nouveau groupe
        group = [i]
        assigned_groups.append(i)
        
        # Vérifier si d'autres feuillets peuvent être ajoutés au groupe
        for j, feuillet2 in enumerate(feuillets):
            if j == i or j in assigned_groups:
                continue
            if are_feuillets_similar(feuillet1, feuillet2):
                group.append(j)
                assigned_groups.append(j)
        
        groups.append(group)
    
    return groups

# Visualisation des groupes avec des couleurs distinctes
def visualize_groups_with_overlay(image, outputs, feuillets, groups):
    # Créer un Visualizer pour afficher les résultats sur l'image
    v = Visualizer(image[:, :, ::-1], metadata=None, scale=1.0)
    
    # Générer une palette de couleurs distinctes à partir de matplotlib
    n_colors = len(groups)
    cmap = mpl.cm.get_cmap('tab20', n_colors)  # Utilisation de la palette 'tab20' de matplotlib
    colors = [cmap(i) for i in range(n_colors)]  # Générer des couleurs distinctes
    
    # Ajouter les instances avec les couleurs de groupe dans l'overlay
    instances = outputs['instances']
    masks = instances.pred_masks.cpu().numpy()  # Masques sous forme de tableau numpy (sur CPU)
    
    # Créer un tableau pour les couleurs des instances
    instance_colors = np.zeros((len(instances), 4))  # Tableau pour stocker les couleurs RGBA
    for group_idx, group in enumerate(groups):
        group_color = colors[group_idx]
        for idx in group:
            instance_colors[idx] = group_color  # Assigner la couleur au feuillet du groupe
    
    # Appliquer l'overlay avec les couleurs associées à chaque instance
    v.overlay_instances(masks=masks, assigned_colors=instance_colors)
    
    # Afficher l'image avec l'overlay des groupes
    result_image = v.get_output().get_image()
    plt.figure(figsize=(10, 10))
    plt.imshow(result_image)
    plt.axis('off')
    plt.show()

# Effectuer l'inférence sur l'image avec le prédicteur existant
def run_inference(image_path, predictor):
    # Charger l'image
    image = cv2.imread(image_path)
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

    # Effectuer l'inférence
    outputs = predictor(image)
    return image, outputs

# Fonction principale pour effectuer l'inférence et afficher les résultats
def main(image_path, predictor):
    # 1. Effectuer l'inférence
    image, outputs = run_inference(image_path, predictor)
    
    # 2. Extraire les feuillets et leurs propriétés
    feuillets = extract_feuillets(outputs)
    
    # 3. Regrouper les feuillets par proximité et orientation
    groups = group_feuillets(feuillets)
    
    # 4. Visualiser les feuillets regroupés avec overlay
    visualize_groups_with_overlay(image, outputs, feuillets, groups)

