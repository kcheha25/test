import cv2
import numpy as np
from sklearn.cluster import DBSCAN
import matplotlib.pyplot as plt

# Étape 1 : Calcul des centres des feuillets
def calculate_centers(masks):
    centers = []
    for mask in masks:
        coords = np.argwhere(mask)  # Coordonnées des pixels du masque
        center = coords.mean(axis=0)  # Moyenne des coordonnées (barycentre)
        centers.append(center)
    return np.array(centers)

# Étape 2 : Calcul de l'orientation des feuillets (approximée par l'angle des boîtes englobantes)
def calculate_orientations(boxes):
    orientations = []
    for box in boxes:
        x1, y1, x2, y2 = box
        angle = np.arctan2(y2 - y1, x2 - x1)  # Calcul de l'angle entre les coins
        orientations.append(angle)
    return np.array(orientations)

# Étape 3 : Regroupement spatial et par orientation
def group_feuillets_spatial_orientation(centers, orientations, eps=20, min_samples=2, orientation_threshold=0.1):
    """Regroupe les feuillets en fonction de leur proximité et de leur orientation."""
    clusters = {}
    for i, (center, orientation) in enumerate(zip(centers, orientations)):
        assigned = False
        for label, (cluster_centers, cluster_orientations) in clusters.items():
            # Vérification de la proximité spatiale
            dist = np.linalg.norm(cluster_centers - center, axis=1)
            if np.min(dist) < eps and np.abs(np.mean(cluster_orientations) - orientation) < orientation_threshold:
                clusters[label][0].append(center)  # Ajouter le centre
                clusters[label][1].append(orientation)  # Ajouter l'orientation
                assigned = True
                break
        if not assigned:  # Si le feuillet n'a pas été assigné à un groupe existant
            clusters[len(clusters)] = ([center], [orientation])
    return clusters

# Étape 4 : Calcul de la longueur moyenne pour chaque cluster
def calculate_cluster_lengths(clusters, masks, boxes):
    cluster_lengths = {}
    for label, (centers, orientations) in clusters.items():
        lengths = []
        for center in centers:
            # Trouver l'index correspondant au centre
            idx = np.argmin(np.linalg.norm(masks - center, axis=1))
            box = boxes[idx]
            length = box[3] - box[1]  # Calculer la hauteur (ou ajuster selon l'orientation)
            lengths.append(length)
        cluster_lengths[label] = np.mean(lengths)
    return cluster_lengths

# Exemple complet
masks = outputs["instances"].pred_masks.cpu().numpy()  # Masques binaires
boxes = outputs["instances"].pred_boxes.tensor.cpu().numpy()  # Bounding boxes

# Calcul des centres
centers = calculate_centers(masks)

# Calcul des orientations (en radians)
orientations = calculate_orientations(boxes)

# Regroupement spatial et orientation
clusters = group_feuillets_spatial_orientation(centers, orientations, eps=30, min_samples=2, orientation_threshold=0.1)

# Calcul des longueurs moyennes
cluster_lengths = calculate_cluster_lengths(clusters, masks, boxes)

# Préparation des données pour l'histogramme
empilement_counts = [len(centers) for centers in clusters.values()]
lengths_means = list(cluster_lengths.values())

# Affichage de l'histogramme
plt.figure(figsize=(10, 6))
plt.bar(empilement_counts, lengths_means, color='skyblue')
plt.xlabel("Nombre de feuillets par empilement")
plt.ylabel("Longueur moyenne (pixels)")
plt.title("Histogramme des longueurs moyennes par empilement (proximité et orientation)")
plt.grid(True)
plt.show()
