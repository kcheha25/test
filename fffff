import cv2
import numpy as np
import random
from math import atan2, degrees
import matplotlib.pyplot as plt
from detectron2.utils.visualizer import Visualizer

# Fonction de calcul de l'angle d'orientation d'un rectangle
def get_angle(x1, y1, x2, y2):
    angle = atan2(y2 - y1, x2 - x1)
    return degrees(angle)

# Vérifier si deux feuillets sont proches et ont des orientations similaires
def are_feuillets_similar(feuillet1, feuillet2, distance_threshold=50, angle_threshold=15):
    # Distance euclidienne entre les centres des feuillets
    distance_position = np.sqrt((feuillet1[0] - feuillet2[0])**2 + (feuillet1[1] - feuillet2[1])**2)
    
    # Différence d'orientation (en degrés)
    distance_orientation = abs(feuillet1[2] - feuillet2[2])
    
    # Vérifier si la distance et l'orientation sont suffisamment proches
    if distance_position < distance_threshold and distance_orientation < angle_threshold:
        return True
    return False

# Extraire les informations des feuillets détectés
def extract_feuillets(outputs):
    instances = outputs['instances']
    feuillets = []
    
    # Récupérer les coordonnées du centre de chaque feuillet et son orientation (angle)
    for i in range(len(instances)):
        bbox = instances[i].pred_boxes.tensor.cpu().numpy().flatten()  # Boîte englobante (sur CPU)
        center_x, center_y = (bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2  # Centre du rectangle
        angle = get_angle(bbox[0], bbox[1], bbox[2], bbox[3])  # Angle d'orientation
        feuillets.append((center_x, center_y, angle))
    
    return feuillets

# Regrouper les feuillets par proximité et orientation
def group_feuillets(feuillets):
    groups = []
    assigned_groups = set()  # Utiliser un ensemble pour les groupes assignés
    
    for i, feuillet1 in enumerate(feuillets):
        if i in assigned_groups:
            continue
        
        # Créer un nouveau groupe
        group = [i]
        assigned_groups.add(i)  # Marquer ce feuillet comme assigné
        
        # Vérifier si d'autres feuillets peuvent être ajoutés au groupe
        for j, feuillet2 in enumerate(feuillets):
            if j == i or j in assigned_groups:
                continue
            if are_feuillets_similar(feuillet1, feuillet2):
                group.append(j)
                assigned_groups.add(j)
        
        groups.append(group)
    
    return groups

# Visualisation des groupes avec des couleurs distinctes
def generate_unique_colors(num_colors):
    colors = []
    for i in range(num_colors):
        # Utilisation de l'espace HSV pour générer une couleur distincte
        hue = i / num_colors  # Espacement uniforme des teintes
        color = plt.cm.hsv(hue)  # Génère une couleur en HSV
        colors.append(tuple(int(c * 255) for c in color[:3]))  # Convertir en RGB avec une gamme [0, 255]
    return colors

# Exemple de génération de couleurs pour les groupes
def visualize_groups_with_overlay(image, outputs, feuillets, groups):
    # Extraire les instances et leur masque
    instances = outputs['instances']
    num_groups = len(groups)  # Nombre de groupes
    colors = generate_unique_colors(num_groups)  # Générer des couleurs uniques pour chaque groupe
    
    # Initialiser une liste de couleurs pour chaque feuillet
    group_colors = []
    
    # Assigner une couleur unique à chaque groupe
    for group in groups:
        for feuillet_idx in group:
            group_colors.append(colors[groups.index(group)])
    
    # Visualiser les groupes avec des couleurs uniques
    v = Visualizer(image[:, :, ::-1], metadata=None, scale=1.2)
    v.overlay_instances(masks=instances.pred_masks, assigned_colors=group_colors)
    result_image = v.get_output().get_image()
    
    plt.imshow(result_image)
    plt.axis('off')
    plt.show() 

# Effectuer l'inférence sur l'image avec le prédicteur existant
def run_inference(image_path, predictor):
    # Charger l'image
    image = cv2.imread(image_path)
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

    # Effectuer l'inférence
    outputs = predictor(image)
    return image, outputs

# Fonction principale pour effectuer l'inférence et afficher les résultats
def main(image_path, predictor):
    # 1. Effectuer l'inférence
    image, outputs = run_inference(image_path, predictor)
    
    # 2. Extraire les feuillets et leurs propriétés
    feuillets = extract_feuillets(outputs)
    
    # 3. Regrouper les feuillets par proximité et orientation
    groups = group_feuillets(feuillets)
    
    # 4. Visualiser les feuillets regroupés avec overlay
    visualize_groups_with_overlay(image, outputs, feuillets, groups)

