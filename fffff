import numpy as np
import cv2
import matplotlib.pyplot as plt
from math import atan2, degrees
from sklearn.cluster import AgglomerativeClustering
from scipy.spatial.distance import squareform
from detectron2.utils.visualizer import Visualizer

# Fonction de calcul de l'angle d'orientation d'un rectangle
def get_angle(x1, y1, x2, y2):
    angle = atan2(y2 - y1, x2 - x1)
    return degrees(angle)

# Fonction pour extraire les informations des feuillets détectés
def extract_feuillets(outputs):
    instances = outputs['instances']
    feuillets = []
    
    for i in range(len(instances)):
        bbox = instances[i].pred_boxes.tensor.cpu().numpy().flatten()  # Boîte englobante (sur CPU)
        center_x, center_y = (bbox[0] + bbox[2]) / 2, (bbox[1] + bbox[3]) / 2  # Centre du rectangle
        angle = get_angle(bbox[0], bbox[1], bbox[2], bbox[3])  # Angle d'orientation
        feuillets.append((center_x, center_y, angle))
    
    return feuillets

# Fonction pour calculer une distance personnalisée (proximité et orientation)
def custom_distance(feuillets, distance_threshold=50, angle_threshold=15):
    n = len(feuillets)
    distances = np.zeros((n, n))

    for i in range(n):
        for j in range(i + 1, n):
            # Calcul de la distance spatiale
            dx = feuillets[i][0] - feuillets[j][0]
            dy = feuillets[i][1] - feuillets[j][1]
            spatial_distance = np.sqrt(dx**2 + dy**2)

            # Calcul de la différence d'orientation
            orientation_diff = abs(feuillets[i][2] - feuillets[j][2])
            orientation_diff = min(orientation_diff, 360 - orientation_diff)  # Modulo 360

            # Si les critères de proximité ne sont pas satisfaits, définir une grande distance
            if spatial_distance > distance_threshold or orientation_diff > angle_threshold:
                distances[i, j] = 1e6  # Grande valeur pour indiquer "pas connectés"
            else:
                distances[i, j] = spatial_distance  # Sinon, utiliser la distance spatiale

            distances[j, i] = distances[i, j]

    return distances

# Regrouper les feuillets par proximité et orientation avec Agglomerative Clustering
def group_feuillets(feuillets, distance_threshold=50):
    distances = custom_distance(feuillets, distance_threshold=distance_threshold)
    distance_matrix = squareform(distances)

    # Appliquer Agglomerative Clustering
    clustering = AgglomerativeClustering(n_clusters=None, affinity='precomputed', linkage='complete',
                                         distance_threshold=distance_threshold)
    labels = clustering.fit_predict(distance_matrix)
    
    # Regrouper les feuillets par labels de clusters
    groups = {}
    for i, label in enumerate(labels):
        if label not in groups:
            groups[label] = []
        groups[label].append(i)
    
    return list(groups.values())

# Visualisation des groupes avec des couleurs distinctes
def visualize_groups_with_overlay(image, outputs, feuillets, groups):
    v = Visualizer(image[:, :, ::-1], metadata=None, scale=1.0)
    
    # Créer un tableau de couleurs distinctes pour chaque groupe
    colors = [tuple(np.random.rand(3)) for _ in groups]
    
    instances = outputs['instances']
    masks = instances.pred_masks.cpu().numpy()  # Masques sous forme de tableau numpy (sur CPU)
    
    # Créer un tableau pour les couleurs des instances
    instance_colors = np.zeros((len(instances), 3))  # Tableau pour stocker les couleurs (RGB)
    
    for group_idx, group in enumerate(groups):
        group_color = colors[group_idx]
        for idx in group:
            instance_colors[idx] = group_color  # Assigner la couleur au feuillet du groupe
    
    # Appliquer l'overlay avec les couleurs associées à chaque instance
    v.overlay_instances(masks=masks, assigned_colors=instance_colors)
    
    # Afficher l'image avec l'overlay des groupes
    result_image = v.get_output().get_image()
    plt.figure(figsize=(10, 10))
    plt.imshow(result_image)
    plt.axis('off')
    plt.show()

# Effectuer l'inférence sur l'image avec le prédicteur existant
def run_inference(image_path, predictor):
    image = cv2.imread(image_path)
    image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

    outputs = predictor(image)
    return image, outputs

# Fonction principale pour effectuer l'inférence et afficher les résultats
def main(image_path, predictor):
    # 1. Effectuer l'inférence
    image, outputs = run_inference(image_path, predictor)
    
    # 2. Extraire les feuillets et leurs propriétés
    feuillets = extract_feuillets(outputs)
    
    # 3. Regrouper les feuillets par proximité et orientation avec Agglomerative Clustering
    groups = group_feuillets(feuillets)
    
    # 4. Visualiser les feuillets regroupés avec overlay
    visualize_groups_with_overlay(image, outputs, feuillets, groups)


