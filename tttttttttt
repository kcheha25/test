import numpy as np
import matplotlib.pyplot as plt
import random

# Étape 1 : Sélection d’un chromatogramme aléatoire
random_idx = random.randint(0, len(df) - 1)
row = truncate(df.iloc[random_idx])

x = np.array(row["x"])
y = np.array(row["y"])

# Étape 2 : Normalisation des intensités
y = y / np.max(y)

# Étape 3 : Segmentation
segments = []
segment_size = 1000
num_segments = len(x) // segment_size

for i in range(num_segments):
    start = i * segment_size
    end = start + segment_size
    segment_x = x[start:end]
    segment_y = y[start:end]
    segment_input = np.stack([segment_x, segment_y], axis=-1)
    segments.append(segment_input)

segments = np.array(segments)  # (n_segments, 1000, 2)

# Étape 4 : Prédiction par le modèle
predictions = model.predict(segments)  # shape: (n_segments, 1000, 1) ou (n_segments, 1000)

if predictions.ndim == 3:
    predictions = predictions[:, :, 0]

# Étape 5 : Reconstruction du signal complet
x_full = np.concatenate([seg[:, 0] for seg in segments])
y_full = np.concatenate([seg[:, 1] for seg in segments])
probs_full = np.concatenate(predictions)

# Étape 6 : Détection des pics
detected_peaks = []
threshold = 0.4

for i in range(3, len(probs_full) - 3):
    if probs_full[i] > threshold:
        window = probs_full[i-3:i+4]
        if np.any(window > threshold):
            idx_window = np.arange(i-3, i+4)
            idx_max_intensity = idx_window[np.argmax(y_full[idx_window])]
            detected_peaks.append(idx_max_intensity)

# Supprimer les doublons
detected_peaks = sorted(set(detected_peaks))

# Étape 7 : Affichage
plt.figure(figsize=(14, 5))
plt.plot(x_full, y_full, label='Chromatogramme')
plt.scatter(x_full[detected_peaks], y_full[detected_peaks], color='red', label='Pics détectés')
plt.xlabel('Temps de rétention')
plt.ylabel('Intensité normalisée')
plt.title('Détection de pics dans le chromatogramme')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

segments = []
x_segments = []
y_segments = []

for i in range(num_segments):
    start = i * segment_size
    end = start + segment_size
    segment_x = x[start:end]
    segment_y = y[start:end]
    segment_input = np.stack([segment_x, segment_y], axis=-1)
    segments.append(segment_input)
    x_segments.append(segment_x)
    y_segments.append(segment_y)

# Étape 4 : Inférence segment par segment
probs_segments = []

for seg in segments:
    seg_input = np.expand_dims(seg, axis=0)  # (1, 1000, 2)
    pred = model.predict(seg_input, verbose=0)  # (1, 1000, 1) ou (1, 1000)
    if pred.ndim == 3:
        pred = pred[0, :, 0]
    else:
        pred = pred[0]
    probs_segments.append(pred)

    x_full = np.concatenate(x_segments)
y_full = np.concatenate(y_segments)
probs_full = np.concatenate(probs_segments)


while i < len(probs_full) - 3:
    if probs_full[i] > threshold:
        window = probs_full[i-3:i+4]
        if np.any(window > threshold):
            idx_window = np.arange(i-3, i+4)
            idx_max_intensity = idx_window[np.argmax(y_full[idx_window])]
            detected_peaks.append(idx_max_intensity)

            # Avancer jusqu'à la fin de la fenêtre (après le pic et la fenêtre de 7 points)
            i = i + 4  # Avancer jusqu'au point juste après la fenêtre
        else:
            i += 1  # Continuer à l'index suivant si aucun pic n'est détecté dans la fenêtre
    else:
        i += 1  # Continuer à l'index suivant si aucun pic n'est détecté

plt.figure(figsize=(14, 5))
plt.plot(x_full, y_full, label='Chromatogramme')
plt.scatter(x_full[detected_peaks], y_full[detected_peaks], color='red', label='Pics détectés')
plt.xlabel('Temps de rétention')
plt.ylabel('Intensité normalisée')
plt.title('Détection de pics dans le chromatogramme')
plt.legend()

# Suppression des axes
plt.axis('off')  # Masquer les axes

# Ajuster les limites des axes pour ne pas avoir de marge
plt.xlim(min(x_full), max(x_full))  # Limiter l'axe x entre le minimum et le maximum de x_full
plt.ylim(min(y_full), max(y_full))  # Limiter l'axe y entre le minimum et le maximum de y_full

# Ajuster la disposition pour qu'il n'y ait pas de marge
plt.tight_layout(pad=0.0)

# Affichage
plt.show()