import numpy as np
import cv2
import json

def generate_density_map(image, points, sigma=15):
    """G√©n√®re une carte de densit√© en remplissant les objets."""
    h, w = image.shape[:2]
    density_map = np.zeros((h, w), dtype=np.float32)

    for obj in points:
        # On suppose que chaque objet est un polygone
        if len(obj) >= 3:  # Un polygone doit avoir au moins 3 points
            polygon = np.array(obj, np.int32).reshape((-1, 1, 2))
            cv2.fillPoly(density_map, [polygon], 1)  # Remplir l'objet entier

    # Appliquer un flou gaussien avec un noyau de taille impaire
    ksize = int(2 * np.ceil(sigma) + 1)  # Assurer que ksize est impair
    density_map = cv2.GaussianBlur(density_map, (ksize, ksize), sigma)
    
    # Normalisation
    density_map /= density_map.sum() if density_map.sum() > 0 else 1
    return density_map
def load_data_from_labelme(image_dir, annotation_dir, target_size=(256, 256)):
    images = []
    density_maps = []

    annotation_files = [f for f in os.listdir(annotation_dir) if f.endswith('.json')]
    
    for ann_name in annotation_files:
        ann_path = os.path.join(annotation_dir, ann_name)
        with open(ann_path, 'r') as f:
            annotation = json.load(f)
        
        image_name = annotation['imagePath']
        image_path = os.path.join(image_dir, image_name)
        
        # Charger et redimensionner l'image
        image = cv2.imread(image_path, cv2.IMREAD_COLOR)
        image = cv2.resize(image, target_size)
        image = image.astype(np.float32) / 255.0  # Normalisation
        images.append(image)

        # Extraire les polygones des annotations LabelMe
        polygons = []
        for shape in annotation['shapes']:
            points = shape['points']  # Liste des points pour chaque objet
            polygons.append(points)

        # G√©n√©rer la carte de densit√©
        density_map = generate_density_map(image, polygons, sigma=10)
        density_map = cv2.resize(density_map, target_size)
        density_maps.append(density_map)

    images = np.array(images)
    density_maps = np.array(density_maps).reshape(-1, target_size[0], target_size[1], 1)  # Ajouter canal

    return images, density_maps
def train_csrnet(image_dir, annotation_dir, epochs=10, batch_size=8):
    # Charger les donn√©es
    X, Y = load_data_from_labelme(image_dir, annotation_dir)
    
    # S√©parer en train et test
    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=42)

    # Construire le mod√®le
    model = build_csrnet()
    model.summary()

    # Entra√Æner le mod√®le
    model.fit(X_train, Y_train, epochs=epochs, batch_size=batch_size, validation_data=(X_test, Y_test))

    # Sauvegarde du mod√®le
    model.save('csrnet_model_labelme.h5')
    print("üìå Mod√®le entra√Æn√© et sauvegard√©.")
